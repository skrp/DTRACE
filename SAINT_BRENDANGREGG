# Glory be to Saint Brendan Gregg
# From him we learn to delve deeper

# Here is a mastertome of his lifeswork

#!/usr/sbin/dtrace -qs
/*
 * kill.d - watch process signals as they are sent (eg, kill -9).
 *          Written in DTrace (Solaris 10 3/05).
 *
 * 16-Jun-2005, ver 1.00
 *
 * USAGE:       kill.d
 *
 * FIELDS:
 *              FROM     source PID
 *              COMMAND  source command name
 *              TO       destination PID
 *              SIG      destination signal ("9" for a kill -9)
 *              RESULT   result of signal (-1 is for failure)
 *
 * SEE ALSO: Chapter 25, Solaris Dynamic Tracing Guide, docs.sun.com,
 *           for a solution using proc:::signal-send.
 *
 * Standard Disclaimer: This is freeware, use at your own risk.
 *
 * 09-May-2004  Brendan Gregg   Created this.
 */

dtrace:::BEGIN
{
	/* Print header */
	printf("%5s %12s %5s %-6s %s\n","FROM","COMMAND","SIG","TO","RESULT");
}

syscall::kill:entry
{
	/* Record target PID and signal */
	self->target = arg0;
	self->signal = arg1;
}

syscall::kill:return
{
	/* Print source, target, and result */
	printf("%5d %12s %5d %-6d %d\n",
	 pid,execname,self->signal,self->target,(int)arg0);

	/* Cleanup memory */
	self->target = 0;
	self->signal = 0;
}

##############################################################
#!/usr/bin/ksh
#
# rwsnoop - snoop read/write events.
#           Written using DTrace (Solaris 10 3/05).
#
# This is measuring reads and writes at the application level. This matches
# the syscalls read, write, pread and pwrite.
#
# 17-Sep-2005, ver 0.75		(check for newer versions)
#
# USAGE:	rwsnoop [-jPtvZ] [-n name] [-p pid]
#
#		rwsnoop		# default output
#
#		-j		# print project ID
#		-P		# print parent process ID
#		-t		# print timestamp, us
#		-v		# print time, string
#		-Z		# print zone ID
#		-n name		# this process name only
#		-p PID		# this PID only
#	eg,
#		rwsnoop -Z		# print zone ID
#		rwsnoop -n bash 	# monitor processes named "bash"
#		rwsnoop > out.txt	# recommended
#
# NOTE:
# 	rwsnoop usually prints plenty of output, which itself will cause
#	more output. It can be better to redirect the output of rwsnoop
#	to a file to prevent this.
#
# FIELDS:
#		TIME		Timestamp, us
#		TIMESTR		Time, string
#		ZONE		Zone ID
#		PROJ		Project ID
#		UID		User ID
#		PID		Process ID
#		PPID		Parent Process ID
#		CMD		Process name
#		D		Direction, Read or Write
#		BYTES		Total bytes during sample, -1 for error
#		FILE		Filename, if file based
#
# Reads and writes that are not file based, for example with sockets, will
# print "<unknown>" as the filename.
#
# SEE ALSO:	rwtop
#
# COPYRIGHT: Copyright (c) 2005 Brendan Gregg.
#
# CDDL HEADER START
#
#  The contents of this file are subject to the terms of the
#  Common Development and Distribution License, Version 1.0 only
#  (the "License").  You may not use this file except in compliance
#  with the License.
#
#  You can obtain a copy of the license at Docs/cddl1.txt
#  or http://www.opensolaris.org/os/licensing.
#  See the License for the specific language governing permissions
#  and limitations under the License.
#
# CDDL HEADER END
#
# TODO:
#  Track readv and writev.
#
# Author: Brendan Gregg  [Sydney, Australia]
#
# 24-Jul-2005   Brendan Gregg   Created this.
# 17-Sep-2005	   "      "	Increased switchrate.
#


##############################
# --- Process Arguments ---
#

### default variables
opt_name=0; opt_pid=0; opt_proj=0; opt_zone=0; opt_time=0; opt_timestr=0
opt_bytes=1; filter=0; pname=.; pid=0; opt_ppid=0

### process options
while getopts n:Pp:jtvZ name
do
	case $name in
	n)	opt_name=1; pname=$OPTARG ;;
	p)	opt_pid=1; pid=$OPTARG ;;
	P)	opt_ppid=1 ;;
	j)	opt_proj=1 ;;
	t)	opt_time=1 ;;
	v)	opt_timestr=1 ;;
	Z)	opt_zone=1 ;;
	h|?)	cat <<-END >&2
		USAGE: rwsnoop [-jPtvZ] [-n name] [-p pid]

		                -j       # print project ID
		                -P       # print parent process ID
		                -t       # print timestamp, us
		                -v       # print time, string
		                -Z       # print zone ID
		                -n name  # this process name only
		                -p PID   # this PID only
		   eg,
		        rwsnoop          # default output
		        rwsnoop -Z       # print zone ID
		        rwsnoop -n bash  # monitor processes named "bash"
		END
		exit 1
	esac
done

shift $(( $OPTIND - 1 ))

### option logic
if (( opt_name || opt_pid )); then
	filter=1
fi



#################################
# --- Main Program, DTrace ---
#
/usr/sbin/dtrace -n '
 /*
  * Command line arguments
  */
 inline int OPT_proj 	= '$opt_proj';
 inline int OPT_zone 	= '$opt_zone';
 inline int OPT_bytes 	= '$opt_bytes';
 inline int OPT_name 	= '$opt_name';
 inline int OPT_ppid 	= '$opt_ppid';
 inline int OPT_pid 	= '$opt_pid';
 inline int OPT_time 	= '$opt_time';
 inline int OPT_timestr	= '$opt_timestr';
 inline int FILTER 	= '$filter';
 inline int PID		= '$pid';
 inline string NAME 	= "'$pname'";

 #pragma D option quiet
 #pragma D option switchrate=10hz

 /*
  * Print header
  */
 dtrace:::BEGIN
 {
	/* print header */
	OPT_time    ? printf("%-14s ", "TIME") : 1;
	OPT_timestr ? printf("%-20s ", "TIMESTR") : 1;
	OPT_proj    ? printf("%5s ", "PROJ") : 1;
	OPT_zone    ? printf("%5s ", "ZONE") : 1;
	OPT_ppid    ? printf("%6s ", "PPID") : 1;
	printf("%5s %6s %-12s %1s %7s %s\n",
	    "UID", "PID", "CMD", "D", "BYTES", "FILE");
 }

 /*
  * Check event is being traced
  */
 syscall::*read:entry,
 syscall::*write:entry
 /pid != $pid/
 {
	/* default is to trace unless filtering, */
	self->ok = FILTER ? 0 : 1;

	/* check each filter, */
	(OPT_name == 1 && NAME == execname)? self->ok = 1 : 1;
	(OPT_pid == 1 && PID == pid) ? self->ok = 1 : 1;

	/* save file descriptor */
	self->fd = self->ok ? arg0 : 0;
 }

 /*
  * Save read details
  */
 syscall::*read:return
 /self->ok/
 {
	self->rw = "R";
	self->size = arg0;
 }

 /*
  * Save write details
  */
 syscall::*write:entry
 /self->ok/
 {
	self->rw = "W";
	self->size = arg2;
 }

 /*
  * Process event
  */
 syscall::*read:return,
 syscall::*write:entry
 /self->ok/
 {
	/*
	 * Fetch filename
	 */
	this->filistp = curthread->t_procp->p_user.u_finfo.fi_list;
	this->ufentryp = (uf_entry_t *)((uint64_t)this->filistp +
	    (uint64_t)self->fd * (uint64_t)sizeof(uf_entry_t));
	this->filep = this->ufentryp->uf_file;
	this->vnodep = this->filep != 0 ? this->filep->f_vnode : 0;
	self->vpath = this->vnodep ? (this->vnodep->v_path != 0 ?
	    cleanpath(this->vnodep->v_path) : "<unknown>") : "<unknown>";

	/*
	 * Print details
	 */
	OPT_time    ? printf("%-14d ", timestamp / 1000) : 1;
	OPT_timestr ? printf("%-20Y ", walltimestamp) : 1;
	OPT_proj    ? printf("%5d ", curpsinfo->pr_projid) : 1;
	OPT_zone    ? printf("%5d ", curpsinfo->pr_zoneid) : 1;
	OPT_ppid    ? printf("%6d ", ppid) : 1;
	printf("%5d %6d %-12.12s %1s %7d %s\n",
	    uid, pid, execname, self->rw, (int)self->size, self->vpath);

	self->ok = 0;
	self->fd = 0;
	self->rw = 0;
	self->size = 0;
	self->vpath = 0;
 }
'
##############################################################
#!/bin/sh
#
# iosnoop - A program to print disk I/O events as they happen, with useful
#           details such as UID, PID, filename (if available), command, etc.
#           Written using DTrace (Solaris 10 3/05, MacOS X 10.5).
#
# This is measuring events that have made it past system caches, such as
# disk events for local file systems, and network events for remote
# filesystems (such as NFS.)
#
# $Id: iosnoop 79 2011-11-14 05:49:44Z brendan $
#
# USAGE: 	iosnoop [-a|-A|-DeghiNostv] [-d device] [-f filename]
#			[-m mount_point] [-n name] [-p PID]
#
#		iosnoop		# default output
#
#		-a		# print all data (mostly)
#		-A		# dump all data, space delimited
#		-D		# print time delta, us (elapsed)
#		-e		# print device name
#		-g		# print command arguments
#		-i		# print device instance
#		-N		# print major and minor numbers
#		-o		# print disk delta time, us
#		-s		# print start time, us
#		-t 		# print completion time, us
#		-v		# print completion time, string
#		-d device	# instance name to snoop (eg, dad0)
#		-f filename	# full pathname of file to snoop
#		-m mount_point	# this FS only (will skip raw events)
#		-n name		# this process name only
#		-p PID		# this PID only
#  eg,
#		iosnoop -v	# human readable timestamps
#		iosnoop -N	# print major and minor numbers
#		iosnoop -m /	# snoop events on the root filesystem only
#
# FIELDS:
#		UID		user ID
#		PID		process ID
#		PPID		parennt process ID
#		COMM		command name for the process
#		ARGS		argument listing for the process
#		SIZE		size of operation, bytes
#		BLOCK		disk block for the operation (location)
#		STIME	 	timestamp for the disk request, us
#		TIME		timestamp for the disk completion, us
#		DELTA		elapsed time from request to completion, us
#		DTIME		time for disk to complete request, us
#		STRTIME		timestamp for the disk completion, string
#		DEVICE  	device name
#		INS     	device instance number
#		D		direction, Read or Write
#		MOUNT		mount point
#		FILE		filename (basename) for io operation
#
# NOTE:
# - There are two different delta times reported. -D prints the
#   elapsed time from the disk request (strategy) to the disk completion
#   (iodone); -o prints the time for the disk to complete that event
#   since it's last event (time between iodones), or, the time to the
#   strategy if the disk had been idle.
# - When filtering on PID or process name, be aware that poor disk event
#   times may be due to events that have been filtered away, for example
#   another process that may be seeking the disk heads elsewhere.
#
# SEE ALSO: BigAdmin: DTrace, http://www.sun.com/bigadmin/content/dtrace
#	    Solaris Dynamic Tracing Guide, http://docs.sun.com
#	    DTrace Tools, http://www.brendangregg.com/dtrace.html
#
# COPYRIGHT: Copyright (c) 2009 Brendan Gregg.
#
# CDDL HEADER START
#
#  The contents of this file are subject to the terms of the
#  Common Development and Distribution License, Version 1.0 only
#  (the "License").  You may not use this file except in compliance
#  with the License.
#
#  You can obtain a copy of the license at Docs/cddl1.txt
#  or http://www.opensolaris.org/os/licensing.
#  See the License for the specific language governing permissions
#  and limitations under the License.
#
# CDDL HEADER END
#
# 12-Mar-2004	Brendan Gregg	Created this, build 51.
# 23-May-2004	   "	  "	Fixed mntpt bug.
# 10-Oct-2004	   "      "	Rewritten to use the io provider, build 63.
# 04-Jan-2005	   "	  "	Wrapped in sh to provide options.
# 08-May-2005	   "      "	Rewritten for perfromance.
# 15-Jul-2005	   "      "	Improved DTIME calculation.
# 25-Jul-2005	   "      "	Added -p, -n. Improved code.
# 17-Sep-2005	   "      "	Increased switchrate.
# 15-Sep-2009	   "      "	Removed genunix for both MacOS X and NFS.
#


##############################
# --- Process Arguments ---
#

### default variables
opt_dump=0; opt_device=0; opt_delta=0; opt_devname=0; opt_file=0; opt_args=0;
opt_mount=0; opt_start=0 opt_end=0; opt_endstr=0; opt_ins=0; opt_nums=0
opt_dtime=0; filter=0; device=.; filename=.; mount=.; pname=.; pid=0
opt_name=0; opt_pid=0

### process options
while getopts aAd:Def:ghim:Nn:op:stv name
do
	case $name in
	a)	opt_devname=1; opt_args=1; opt_endstr=1; opt_nums=1 ;;
	A)	opt_dump=1 ;;
	d)	opt_device=1; device=$OPTARG ;;
	D)	opt_delta=1 ;;
	e)	opt_devname=1 ;;
	f)	opt_file=1; filename=$OPTARG ;;
	g)	opt_args=1 ;;
	i)	opt_ins=1 ;;
	N)	opt_nums=1 ;;
	n)	opt_name=1; pname=$OPTARG ;;
	o)	opt_dtime=1 ;;
	p)	opt_pid=1; pid=$OPTARG ;;
	m)	opt_mount=1; mount=$OPTARG ;;
	s)	opt_start=1 ;;
	t)	opt_end=1 ;;
	v)	opt_endstr=1 ;;
	h|?)	cat <<-END >&2
		USAGE: iosnoop [-a|-A|-DeghiNostv] [-d device] [-f filename]
		               [-m mount_point] [-n name] [-p PID]
		       iosnoop          # default output
		                -a      # print all data (mostly)
		                -A      # dump all data, space delimited
		                -D      # print time delta, us (elapsed)
		                -e      # print device name
		                -g      # print command arguments
		                -i      # print device instance
		                -N      # print major and minor numbers
		                -o      # print disk delta time, us
		                -s      # print start time, us
		                -t      # print completion time, us
		                -v      # print completion time, string
		                -d device       # instance name to snoop
		                -f filename     # snoop this file only
		                -m mount_point  # this FS only
		                -n name         # this process name only
		                -p PID          # this PID only
		   eg,
		        iosnoop -v      # human readable timestamps
		        iosnoop -N      # print major and minor numbers
		        iosnoop -m /    # snoop events on filesystem / only
		END
		exit 1
	esac
done

### option logic
if [ $opt_dump -eq 1 ]; then
	opt_delta=0; opt_devname=0; opt_args=2; opt_start=0;
	opt_end=0; opt_endstr=0; opt_nums=0; opt_ins=0; opt_dtime=0
fi
if [ $opt_device -eq 1 -o $opt_file -eq 1 -o $opt_mount -eq 1 -o \
    $opt_name -eq 1 -o $opt_pid -eq 1 ]; then
	filter=1
fi


#################################
# --- Main Program, DTrace ---
#
/usr/sbin/dtrace -n '
 /*
  * Command line arguments
  */
 inline int OPT_dump 	= '$opt_dump';
 inline int OPT_device 	= '$opt_device';
 inline int OPT_delta 	= '$opt_delta';
 inline int OPT_devname = '$opt_devname';
 inline int OPT_file 	= '$opt_file';
 inline int OPT_args 	= '$opt_args';
 inline int OPT_ins  	= '$opt_ins';
 inline int OPT_nums  	= '$opt_nums';
 inline int OPT_dtime 	= '$opt_dtime';
 inline int OPT_mount 	= '$opt_mount';
 inline int OPT_start 	= '$opt_start';
 inline int OPT_pid 	= '$opt_pid';
 inline int OPT_name 	= '$opt_name';
 inline int OPT_end 	= '$opt_end';
 inline int OPT_endstr 	= '$opt_endstr';
 inline int FILTER 	= '$filter';
 inline int PID 	= '$pid';
 inline string DEVICE 	= "'$device'";
 inline string FILENAME = "'$filename'";
 inline string MOUNT 	= "'$mount'";
 inline string NAME 	= "'$pname'";

 #pragma D option quiet
 #pragma D option switchrate=10hz

 /* boost the following if you get "dynamic variable drops" */
 #pragma D option dynvarsize=16m

 /*
  * Print header
  */
 dtrace:::BEGIN
 {
	last_event[""] = 0;

	/* print optional headers */
 	OPT_start   ? printf("%-14s ","STIME(us)")   : 1;
 	OPT_end     ? printf("%-14s ","TIME(us)")    : 1;
 	OPT_endstr  ? printf("%-20s ","STRTIME") : 1;
 	OPT_devname ? printf("%-7s ","DEVICE")   : 1;
 	OPT_ins     ? printf("%-3s ","INS")      : 1;
 	OPT_nums    ? printf("%-3s %-3s ","MAJ","MIN") : 1;
 	OPT_delta   ? printf("%-10s ","DELTA(us)")   : 1;
 	OPT_dtime   ? printf("%-10s ","DTIME(us)")   : 1;

	/* print main headers */
	OPT_dump ?
	    printf("%s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s\n",
 	    "TIME", "STIME", "DELTA", "DEVICE", "INS", "MAJ", "MIN", "UID",
	    "PID", "PPID", "D", "BLOCK", "SIZE", "MOUNT", "FILE", "PATH",
	    "COMM","ARGS") :
 	    printf("%5s %5s %1s %8s %6s ", "UID", "PID", "D", "BLOCK", "SIZE");
	OPT_args == 0 ? printf("%10s %s\n", "COMM", "PATHNAME") : 1;
 	OPT_args == 1 ? printf("%28s %s\n", "PATHNAME", "ARGS") : 1;
 }

 /*
  * Check event is being traced
  */
 io:::start
 {
	/* default is to trace unless filtering, */
	self->ok = FILTER ? 0 : 1;

	/* check each filter, */
	(OPT_device == 1 && DEVICE == args[1]->dev_statname)? self->ok = 1 : 1;
	(OPT_file == 1 && FILENAME == args[2]->fi_pathname) ? self->ok = 1 : 1;
	(OPT_mount == 1 && MOUNT == args[2]->fi_mount) ? self->ok = 1 : 1;
	(OPT_name == 1 && NAME == execname) ? self->ok = 1 : 1;
	(OPT_pid == 1 && PID == pid) ? self->ok = 1 : 1;
 }

 /*
  * Reset last_event for disk idle -> start
  * this prevents idle time being counted as disk time.
  */
 io:::start
 /! pending[args[1]->dev_statname]/
 {
	/* save last disk event */
	last_event[args[1]->dev_statname] = timestamp;
 }

 /*
  * Store entry details
  */
 io:::start
 /self->ok/
 {
	/* these are used as a unique disk event key, */
 	this->dev = args[0]->b_edev;
 	this->blk = args[0]->b_blkno;

	/* save disk event details, */
 	start_uid[this->dev, this->blk] = uid;
 	start_pid[this->dev, this->blk] = pid;
 	start_ppid[this->dev, this->blk] = ppid;
 	start_args[this->dev, this->blk] = (char *)curpsinfo->pr_psargs;
 	start_comm[this->dev, this->blk] = execname;
 	start_time[this->dev, this->blk] = timestamp;

	/* increase disk event pending count */
	pending[args[1]->dev_statname]++;

	self->ok = 0;
 }

 /*
  * Process and Print completion
  */
 io:::done
 /start_time[args[0]->b_edev, args[0]->b_blkno]/
 {
	/* decrease disk event pending count */
	pending[args[1]->dev_statname]--;

	/*
	 * Process details
	 */

 	/* fetch entry values */
 	this->dev = args[0]->b_edev;
 	this->blk = args[0]->b_blkno;
 	this->suid = start_uid[this->dev, this->blk];
 	this->spid = start_pid[this->dev, this->blk];
 	this->sppid = start_ppid[this->dev, this->blk];
 	self->sargs = (int)start_args[this->dev, this->blk] == 0 ?
 	    "" : start_args[this->dev, this->blk];
 	self->scomm = start_comm[this->dev, this->blk];
 	this->stime = start_time[this->dev, this->blk];
	this->etime = timestamp; /* endtime */
	this->delta = this->etime - this->stime;
	this->dtime = last_event[args[1]->dev_statname] == 0 ? 0 :
	    timestamp - last_event[args[1]->dev_statname];

 	/* memory cleanup */
 	start_uid[this->dev, this->blk]  = 0;
 	start_pid[this->dev, this->blk]  = 0;
 	start_ppid[this->dev, this->blk] = 0;
 	start_args[this->dev, this->blk] = 0;
 	start_time[this->dev, this->blk] = 0;
 	start_comm[this->dev, this->blk] = 0;
 	start_rw[this->dev, this->blk]   = 0;

	/*
	 * Print details
	 */

	/* print optional fields */
 	OPT_start   ? printf("%-14d ", this->stime/1000) : 1;
 	OPT_end     ? printf("%-14d ", this->etime/1000) : 1;
 	OPT_endstr  ? printf("%-20Y ", walltimestamp) : 1;
 	OPT_devname ? printf("%-7s ", args[1]->dev_statname) : 1;
 	OPT_ins     ? printf("%3d ", args[1]->dev_instance) : 1;
 	OPT_nums    ? printf("%3d %3d ",
	    args[1]->dev_major, args[1]->dev_minor) : 1;
 	OPT_delta   ? printf("%-10d ", this->delta/1000) : 1;
 	OPT_dtime   ? printf("%-10d ", this->dtime/1000) : 1;

	/* print main fields */
	OPT_dump ?
 	    printf("%d %d %d %s %d %d %d %d %d %d %s %d %d %s %s %s %s %S\n",
 	    this->etime/1000, this->stime/1000, this->delta/1000,
 	    args[1]->dev_statname, args[1]->dev_instance, args[1]->dev_major,
	    args[1]->dev_minor, this->suid, this->spid, this->sppid,
	    args[0]->b_flags & B_READ ? "R" : "W",
	    args[0]->b_blkno, args[0]->b_bcount, args[2]->fi_mount,
	    args[2]->fi_name, args[2]->fi_pathname, self->scomm, self->sargs) :
 	    printf("%5d %5d %1s %8d %6d ",
 	    this->suid, this->spid, args[0]->b_flags & B_READ ? "R" : "W",
	    args[0]->b_blkno, args[0]->b_bcount);
	OPT_args == 0 ? printf("%10s %s\n", self->scomm, args[2]->fi_pathname)
	    : 1;
 	OPT_args == 1 ? printf("%28s %S\n",
	    args[2]->fi_pathname, self->sargs) : 1;

	/* save last disk event */
	last_event[args[1]->dev_statname] = timestamp;

	/* cleanup */
	self->scomm = 0;
	self->sargs = 0;
 }

 /*
  * Prevent pending from underflowing
  * this can happen if this program is started during disk events.
  */
 io:::done
 /pending[args[1]->dev_statname] < 0/
 {
	pending[args[1]->dev_statname] = 0;
 }
'
##############################################################
#!/usr/bin/ksh
#
# iotop - display top disk I/O events by process.
#         Written using DTrace (Solaris 10 3/05).
#
# This is measuring disk events that have made it past system caches.
#
# 20-Apr-2006, ver 0.76
#
# USAGE:	iotop [-C] [-D|-o|-P] [-j|-Z] [-d device] [-f filename]
#		      [-m mount_point] [-t top] [interval [count]]
#
#		iotop   	# default output, 5 second intervals
#
#		-C		# don't clear the screen
#		-D		# print delta times, elapsed, us
#		-j		# print project ID
#		-o		# print disk delta times, us
#		-P		# print %I/O (disk delta times)
#		-Z		# print zone ID
#		-d device	# instance name to snoop (eg, dad0)
#		-f filename	# full pathname of file to snoop
#		-m mount_point	# this FS only (will skip raw events)
#		-t top		# print top number only
#	eg,
#		iotop 1  	# 1 second samples
#		iotop -C	# don't clear the screen
#		iotop -P	# print %I/O (time based)
#		iotop -j	# print project IDs
#		iotop -Z 	# print zone IDs
#		iotop -t 20 	# print top 20 lines only
#		iotop -C 5 12	# print 12 x 5 second samples
#
# FIELDS:
#		UID		user ID
#		PID		process ID
#		PPID		parent process ID
#		PROJ		project ID
#		ZONE		zone ID
#		CMD		process command name
#		DEVICE  	device name
#		MAJ     	device major number
#		MIN     	device minor number
#		D		direction, Read or Write
#		BYTES		total size of operations, bytes
#		ELAPSED		total elapsed from request to completion, us
#		DISKTIME	total time for disk to complete request, us
#		%I/O		percent disk I/O, based on time (DISKTIME)
#		load		1 min load average
#		disk_r		total disk read Kbytes for sample
#		disk_w		total disk write Kbytes for sample
#
# NOTE:
# * There are two different delta times reported. -D prints the
#   elapsed time from the disk request (strategy) to the disk completion
#   (iodone); -o prints the time for the disk to complete that event
#   since it's last event (time between iodones), or, the time to the
#   strategy if the disk had been idle.
# * The %I/O value can exceed 100%. It represents how busy a process is
#   making the disks, in terms of a single disk. A value of 200% could
#   mean 2 disks are busy at 100%, or 4 disks at 50%...
#
# SEE ALSO: iosnoop
#	    BigAdmin: DTrace, http://www.sun.com/bigadmin/content/dtrace
#	    Solaris Dynamic Tracing Guide, http://docs.sun.com
#	    DTrace Tools, http://www.brendangregg.com/dtrace.html
#
# INSPIRATION:  top(1) by William LeFebvre
#
# COPYRIGHT: Copyright (c) 2005, 2006 Brendan Gregg.
#
# CDDL HEADER START
#
#  The contents of this file are subject to the terms of the
#  Common Development and Distribution License, Version 1.0 only
#  (the "License").  You may not use this file except in compliance
#  with the License.
#
#  You can obtain a copy of the license at Docs/cddl1.txt
#  or http://www.opensolaris.org/os/licensing.
#  See the License for the specific language governing permissions
#  and limitations under the License.
#
# CDDL HEADER END
#
# KNOWN BUGS:
# - This can print errors while running on servers with Veritas volumes.
#
# Author: Brendan Gregg  [Sydney, Australia]
#
# 15-Jul-2005	Brendan Gregg	Created this.
#


##############################
# --- Process Arguments ---
#

### default variables
opt_device=0; opt_file=0; opt_mount=0; opt_clear=1; opt_proj=0; opt_zone=0
opt_percent=0; opt_def=1; opt_bytes=1; filter=0; device=.; filename=.; mount=.
opt_top=0; opt_elapsed=0; opt_dtime=0; interval=5; count=-1; top=0

### process options
while getopts CDd:f:hjm:oPt:Z name
do
	case $name in
	C)	opt_clear=0 ;;
	D)	opt_elapsed=1; opt_bytes=0 ;;
	d)	opt_device=1; device=$OPTARG ;;
	f)	opt_file=1; filename=$OPTARG ;;
	j)	opt_proj=1; opt_def=0 ;;
	m)	opt_mount=1; mount=$OPTARG ;;
	o)	opt_dtime=1; opt_bytes=0 ;;
	P)	opt_percent=1; opt_dtime=1; opt_bytes=0 ;;
	t)	opt_top=1; top=$OPTARG ;;
	Z)	opt_zone=1; opt_def=0 ;;
	h|?)	cat <<-END >&2
		USAGE: iotop [-C] [-D|-o|-P] [-j|-Z] [-d device] [-f filename]
		             [-m mount_point] [-t top] [interval [count]]

		                -C      # don't clear the screen
		                -D      # print delta times, elapsed, us
		                -j      # print project ID
		                -o      # print disk delta times, us
		                -P      # print %I/O (disk delta times)
		                -Z      # print zone ID
		                -d device       # instance name to snoop
		                -f filename     # snoop this file only
		                -m mount_point  # this FS only
		                -t top  	# print top number only
		   eg,
		        iotop         # default output, 5 second samples
		        iotop 1       # 1 second samples
		        iotop -P      # print %I/O (time based)
		        iotop -m /    # snoop events on filesystem / only
		        iotop -t 20   # print top 20 lines only
		        iotop -C 5 12 # print 12 x 5 second samples
		END
		exit 1
	esac
done

shift $(( $OPTIND - 1 ))

### option logic
if [[ "$1" > 0 ]]; then
        interval=$1; shift
fi
if [[ "$1" > 0 ]]; then
        count=$1; shift
fi
if (( opt_proj && opt_zone )); then
        opt_proj=0
fi
if (( opt_elapsed && opt_dtime )); then
        opt_elapsed=0
fi
if (( opt_device || opt_mount || opt_file )); then
	filter=1
fi
if (( opt_clear )); then
        clearstr=`clear`
else
        clearstr=.
fi



#################################
# --- Main Program, DTrace ---
#
/usr/sbin/dtrace -n '
 /*
  * Command line arguments
  */
 inline int OPT_def 	= '$opt_def';
 inline int OPT_proj 	= '$opt_proj';
 inline int OPT_zone 	= '$opt_zone';
 inline int OPT_clear 	= '$opt_clear';
 inline int OPT_bytes 	= '$opt_bytes';
 inline int OPT_elapsed = '$opt_elapsed';
 inline int OPT_dtime 	= '$opt_dtime';
 inline int OPT_percent	= '$opt_percent';
 inline int OPT_device 	= '$opt_device';
 inline int OPT_mount 	= '$opt_mount';
 inline int OPT_file 	= '$opt_file';
 inline int OPT_top 	= '$opt_top';
 inline int INTERVAL 	= '$interval';
 inline int COUNTER 	= '$count';
 inline int FILTER 	= '$filter';
 inline int TOP 	= '$top';
 inline string DEVICE 	= "'$device'";
 inline string FILENAME = "'$filename'";
 inline string MOUNT 	= "'$mount'";
 inline string CLEAR 	= "'$clearstr'";

 #pragma D option quiet

 /*
  * Print header
  */
 dtrace:::BEGIN
 {
	last_event[""] = 0;

        /* starting values */
        counts = COUNTER;
        secs = INTERVAL;
        disk_r = 0;
        disk_w = 0;

        printf("Tracing... Please wait.\n");
 }

 /*
  * Check event is being traced
  */
 io:genunix::start,
 io:genunix::done
 {
	/* default is to trace unless filtering, */
	this->ok = FILTER ? 0 : 1;

	/* check each filter, */
	(OPT_device == 1 && DEVICE == args[1]->dev_statname)? this->ok = 1 : 1;
	(OPT_file == 1 && FILENAME == args[2]->fi_pathname) ? this->ok = 1 : 1;
	(OPT_mount == 1 && MOUNT == args[2]->fi_mount)  ? this->ok = 1 : 1;
 }

 /*
  * Reset last_event for disk idle -> start
  * this prevents idle time being counted as disk time.
  */
 io:genunix::start
 /! pending[args[1]->dev_statname]/
 {
	/* save last disk event */
	last_event[args[1]->dev_statname] = timestamp;
 }

 /*
  * Store entry details
  */
 io:genunix::start
 /this->ok/
 {
	/* these are used as a unique disk event key, */
 	this->dev = args[0]->b_edev;
 	this->blk = args[0]->b_blkno;

	/* save disk event details, */
 	start_uid[this->dev, this->blk] = uid;
 	start_pid[this->dev, this->blk] = pid;
 	start_ppid[this->dev, this->blk] = ppid;
 	start_comm[this->dev, this->blk] = execname;
 	start_time[this->dev, this->blk] = timestamp;
 	start_proj[this->dev, this->blk] = curpsinfo->pr_projid;
 	start_zone[this->dev, this->blk] = curpsinfo->pr_zoneid;
 	start_rw[this->dev, this->blk] = args[0]->b_flags & B_READ ? "R" : "W";
	disk_r += args[0]->b_flags & B_READ ? args[0]->b_bcount : 0;
	disk_w += args[0]->b_flags & B_READ ? 0 : args[0]->b_bcount;

	/* increase disk event pending count */
	pending[args[1]->dev_statname]++;
 }

 /*
  * Process and Print completion
  */
 io:genunix::done
 /this->ok/
 {
	/* decrease disk event pending count */
	pending[args[1]->dev_statname]--;

	/*
	 * Process details
	 */

 	/* fetch entry values */
 	this->dev = args[0]->b_edev;
 	this->blk = args[0]->b_blkno;
 	this->suid = start_uid[this->dev, this->blk];
 	this->spid = start_pid[this->dev, this->blk];
 	this->sppid = start_ppid[this->dev, this->blk];
 	this->sproj = start_proj[this->dev, this->blk];
 	this->szone = start_zone[this->dev, this->blk];
 	self->scomm = start_comm[this->dev, this->blk];
 	this->stime = start_time[this->dev, this->blk];
	this->etime = timestamp; /* endtime */
	this->elapsed = this->etime - this->stime;
 	self->rw = start_rw[this->dev, this->blk];
	this->dtime = last_event[args[1]->dev_statname] == 0 ? 0 :
	    timestamp - last_event[args[1]->dev_statname];

 	/* memory cleanup */
 	start_uid[this->dev, this->blk]  = 0;
 	start_pid[this->dev, this->blk]  = 0;
 	start_ppid[this->dev, this->blk] = 0;
 	start_time[this->dev, this->blk] = 0;
 	start_comm[this->dev, this->blk] = 0;
 	start_zone[this->dev, this->blk] = 0;
 	start_proj[this->dev, this->blk] = 0;
 	start_rw[this->dev, this->blk]   = 0;

	/*
	 * Choose statistic to track
	 */
	OPT_bytes   ? this->value = args[0]->b_bcount    : 1;
	OPT_elapsed ? this->value = this->elapsed / 1000 : 1;
	OPT_dtime   ? this->value = this->dtime / 1000   : 1;

	/*
	 * Save details
	 */
	OPT_def ? @out[this->suid, this->spid, this->sppid, self->scomm,
	    args[1]->dev_statname, args[1]->dev_major, args[1]->dev_minor,
	    self->rw] = sum(this->value) : 1;
	OPT_proj ? @out[this->sproj, this->spid, this->sppid, self->scomm,
	    args[1]->dev_statname, args[1]->dev_major, args[1]->dev_minor,
	    self->rw] = sum(this->value) : 1;
	OPT_zone ? @out[this->szone, this->spid, this->sppid, self->scomm,
	    args[1]->dev_statname, args[1]->dev_major, args[1]->dev_minor,
	    self->rw] = sum(this->value) : 1;

	/* save last disk event */
	last_event[args[1]->dev_statname] = timestamp;

	self->scomm = 0;
	self->rw = 0;
 }

 /*
  * Prevent pending from underflowing
  * this can happen if this program is started during disk events.
  */
 io:genunix::done
 /pending[args[1]->dev_statname] < 0/
 {
	pending[args[1]->dev_statname] = 0;
 }

 /*
  * Timer
  */
 profile:::tick-1sec
 {
	secs--;
 }

 /*
  * Print Report
  */
 profile:::tick-1sec
 /secs == 0/
 {
	/* fetch 1 min load average */
	this->load1a  = `hp_avenrun[0] / 65536;
	this->load1b  = ((`hp_avenrun[0] % 65536) * 100) / 65536;

	/* convert counters to Kbytes */
	disk_r /= 1024;
	disk_w /= 1024;

	/* print status */
	OPT_clear ? printf("%s", CLEAR) : 1;
	printf("%Y,  load: %d.%02d,  disk_r: %6d KB,  disk_w: %6d KB\n\n",
	    walltimestamp, this->load1a, this->load1b, disk_r, disk_w);

	/* print headers */
	OPT_def  ? printf("  UID ") : 1;
	OPT_proj ? printf(" PROJ ") : 1;
	OPT_zone ? printf(" ZONE ") : 1;
	printf("%6s %6s %-16s %-7s %3s %3s %1s",
	    "PID", "PPID", "CMD", "DEVICE", "MAJ", "MIN", "D");
	OPT_bytes   ? printf(" %16s\n", "BYTES") : 1;
	OPT_elapsed ? printf(" %16s\n", "ELAPSED") : 1;
	OPT_dtime && ! OPT_percent  ? printf(" %16s\n", "DISKTIME") : 1;
	OPT_dtime && OPT_percent    ? printf(" %6s\n", "%I/O") : 1;

	/* truncate to top lines if needed */
	OPT_top ? trunc(@out, TOP) : 1;

	/* normalise to percentage if needed */
	OPT_percent ? normalize(@out, INTERVAL * 10000) : 1;

	/* print data */
	! OPT_percent ?
	    printa("%5d %6d %6d %-16s %-7s %3d %3d %1s %16@d\n", @out) :
	    printa("%5d %6d %6d %-16s %-7s %3d %3d %1s %6@d\n", @out);
	printf("\n");

	/* clear data */
	trunc(@out);
	disk_r = 0;
	disk_w = 0;
	secs = INTERVAL;
	counts--;
 }

 /*
  * End of program
  */
 profile:::tick-1sec
 /counts == 0/
 {
	exit(0);
 }

 /*
  * Cleanup for Ctrl-C
  */
 dtrace:::END
 {
	trunc(@out);
 }
'

##############################################################
#!/usr/bin/sh
#
# execsnoop - snoop process execution as it occurs.
#             Written using DTrace (Solaris 10 3/05).
#
# 11-Sep-2005, ver 1.25
#
# USAGE:	execsnoop [-a|-A|-ehjsvZ] [-c command]
#
#		execsnoop	# default output
#
#		-a		# print all data
#		-A		# dump all data, space delimited
#		-e		# safe output - parseable
#		-j		# print project ID
#		-s		# print start time, us
#		-v		# print start time, string
#		-Z		# print zonename
#		-c command	# command name to snoop
#	eg,
#		execsnoop -v		# human readable timestamps
#		execsnoop -Z		# print zonename
#		execsnoop -c ls		# snoop ls commands only
#
# The parseable output ensures that the ARGS field doesn't contain
# any "\n"s, which normally sometimes can - and would wreck postprocessing.
#
# FIELDS:
#		UID		User ID
#		PID		Process ID
#		PPID		Parent Process ID
#		COMM		command name for the process
#		ARGS		argument listing for the process
#		ZONE		zonename
#		PROJ		project ID
#		TIME		timestamp for the command, us
#		STRTIME		timestamp for the command, string
#
# SEE ALSO: BSM auditing.
#
# COPYRIGHT: Copyright (c) 2005 Brendan Gregg.
#
# CDDL HEADER START
#
#  The contents of this file are subject to the terms of the
#  Common Development and Distribution License, Version 1.0 only
#  (the "License").  You may not use this file except in compliance
#  with the License.
#
#  You can obtain a copy of the license at Docs/cddl1.txt
#  or http://www.opensolaris.org/os/licensing.
#  See the License for the specific language governing permissions
#  and limitations under the License.
#
# CDDL HEADER END
#
# Author: Brendan Gregg  [Sydney, Australia]
#
# 27-Mar-2004	Brendan Gregg	Created this.
# 21-Jan-2005	   "	  "	Wrapped in sh to provide options.
# 08-May-2005 	   "      "	Rewritten for performance.
# 14-May-2005 	   "      "	Added zonename.
# 02-Jul-2005 	   "      "	Added projid, safe printing.
# 11-Sep-2005	   "      "	Increased switchrate.
#


##############################
# --- Process Arguments ---
#

### default variables
opt_dump=0; opt_cmd=0; opt_time=0; opt_timestr=0; filter=0; command=.
opt_zone=0; opt_safe=0; opt_proj=0

### process options
while getopts aAc:ehjsvZ name
do
	case $name in
	a)	opt_time=1; opt_timestr=1; opt_zone=1; opt_proj=1 ;;
	A)	opt_dump=1 ;;
	c)	opt_cmd=1; command=$OPTARG ;;
	e)	opt_safe=1 ;;
	j)	opt_proj=1 ;;
	s)	opt_time=1 ;;
	v)	opt_timestr=1 ;;
	Z)	opt_zone=1 ;;
	h|?)	cat <<-END >&2
		USAGE: execsnoop [-a|-A|-ehjsvZ] [-c command]
		       execsnoop                # default output
		                -a              # print all data
		                -A              # dump all data, space delimited
		                -e              # safe output, parseable
		                -j              # print project ID
		                -s              # print start time, us
		                -v              # print start time, string
		                -Z              # print zonename
		                -c command      # command name to snoop
		  eg,
		        execsnoop -v            # human readable timestamps
		        execsnoop -Z		# print zonename
		        execsnoop -c ls         # snoop ls commands only
		END
		exit 1
	esac
done

### option logic
if [ $opt_dump -eq 1 ]; then
	opt_time=0; opt_timestr=0; opt_zone=0; opt_proj=0
fi
if [ $opt_cmd -eq 1 ]; then
	filter=1
fi


#################################
# --- Main Program, DTrace ---
#
/usr/sbin/dtrace -n '
 /*
  * Command line arguments
  */
 inline int OPT_dump 	= '$opt_dump';
 inline int OPT_cmd 	= '$opt_cmd';
 inline int OPT_time 	= '$opt_time';
 inline int OPT_timestr	= '$opt_timestr';
 inline int OPT_zone 	= '$opt_zone';
 inline int OPT_safe 	= '$opt_safe';
 inline int OPT_proj 	= '$opt_proj';
 inline int FILTER 	= '$filter';
 inline string COMMAND 	= "'$command'";

 #pragma D option quiet
 #pragma D option switchrate=10hz

 /*
  * Print header
  */
 dtrace:::BEGIN
 {
	/* print optional headers */
 	OPT_time    ? printf("%-14s ", "TIME") : 1;
 	OPT_timestr ? printf("%-20s ", "STRTIME") : 1;
 	OPT_zone    ? printf("%-10s ", "ZONE") : 1;
 	OPT_proj    ? printf("%5s ", "PROJ") : 1;

	/* print main headers */
	OPT_dump    ? printf("%s %s %s %s %s %s %s %s\n",
	    "TIME", "ZONE", "PROJ", "UID", "PID", "PPID", "COMM", "ARGS") :
	    printf("%5s %6s %6s %s\n", "UID", "PID", "PPID", "ARGS");
 }

 /*
  * Print exec event
  */
 syscall::exec:return, syscall::exece:return
 /(FILTER == 0) || (OPT_cmd == 1 && COMMAND == execname)/
 {
	/* print optional fields */
 	OPT_time ? printf("%-14d ", timestamp/1000) : 1;
	OPT_timestr ? printf("%-20Y ", walltimestamp) : 1;
 	OPT_zone ? printf("%-10s ", zonename) : 1;
 	OPT_proj ? printf("%5d ", curpsinfo->pr_projid) : 1;

	/* print main data */
	OPT_dump ? printf("%d %s %d %d %d %d %s ", timestamp/1000,
	    zonename, curpsinfo->pr_projid, uid, pid, ppid, execname) :
	    printf("%5d %6d %6d ", uid, pid, ppid);
	OPT_safe ? printf("%S\n", curpsinfo->pr_psargs) :
	    printf("%s\n", curpsinfo->pr_psargs);
 }
'
##############################################################
#!/usr/bin/ksh
#
# rwtop - display top read/write bytes by process.
#         Written using DTrace (Solaris 10 3/05).
#
# This is measuring reads and writes at the application level. This matches
# read and write system calls.
#
# 24-Jul-2005, ver 0.70
#
# USAGE:	rwtop [-cC] [-j|-Z] [-n name] [-p pid]
#		      [-t top] [interval [count]]
#
#		rwtop		# default output, 5 second samples
#
#		-C		# don't clear the screen
#		-c		# print counts
#		-j		# print project ID
#		-Z		# print zone ID
#		-n name		# this process name only
#		-p PID		# this PID only
#		-t top		# print top number only
#	eg,
#		rwtop 1		# 1 second samples
#		rwtop -t 10	# print top 10 only
#		rwtop -n bash	# monitor processes named "bash"
#		rwtop -C 5 12	# print 12 x 5 second samples
#
# FIELDS:
#		ZONE		Zone ID
#		PROJ		Project ID
#		UID		User ID
#		PID		Process ID
#		PPID		Parent Process ID
#		CMD		Process name
#		D		Direction, Read or Write
#		BYTES		Total bytes during sample
#		app_r		total reads during sample, Kb
#		app_w		total writes during sample, Kb
#
# SEE ALSO:	iotop
#
# INSPIRATION:  top(1) by William LeFebvre
#
# COPYRIGHT: Copyright (c) 2005 Brendan Gregg.
#
# CDDL HEADER START
#
#  The contents of this file are subject to the terms of the
#  Common Development and Distribution License, Version 1.0 only
#  (the "License").  You may not use this file except in compliance
#  with the License.
#
#  You can obtain a copy of the license at Docs/cddl1.txt
#  or http://www.opensolaris.org/os/licensing.
#  See the License for the specific language governing permissions
#  and limitations under the License.
#
# CDDL HEADER END
#
# Author: Brendan Gregg  [Sydney, Australia]
#
# 24-Jul-2005   Brendan Gregg   Created this.


##############################
# --- Process Arguments ---
#

### default variables
opt_name=0; opt_pid=0; opt_clear=1; opt_proj=0; opt_zone=0
opt_def=1; opt_bytes=1; filter=0; pname=.; pid=0
opt_top=0; opt_count=0; interval=5; count=-1; top=0

### process options
while getopts Ccn:p:jt:Z name
do
	case $name in
	C)	opt_clear=0 ;;
	c)	opt_count=1; opt_bytes=0 ;;
	n)	opt_name=1; pname=$OPTARG ;;
	p)	opt_pid=1; pid=$OPTARG ;;
	j)	opt_proj=1; opt_def=0 ;;
	t)	opt_top=1; top=$OPTARG ;;
	Z)	opt_zone=1; opt_def=0 ;;
	h|?)	cat <<-END >&2
		USAGE: rwtop [-cC] [-j|-Z] [-n name] [-p pid]
		             [-t top] [interval [count]]

		                -C        # don't clear the screen
		                -c        # print counts
		                -j        # print project ID
		                -Z        # print zone ID
		                -n name   # this process name only
		                -p PID    # this PID only
		                -t top    # print top number only
		   eg,
		        rwtop          # default output, 5 second samples
		        rwtop 1        # 1 second samples
		        rwtop -t 10    # print top 10 only
		        rwtop -n bash  # monitor processes named "bash"
		        rwtop -C 5 12  # print 12 x 5 second samples
		END
		exit 1
	esac
done

shift $(( $OPTIND - 1 ))

### option logic
if [[ "$1" > 0 ]]; then
        interval=$1; shift
fi
if [[ "$1" > 0 ]]; then
        count=$1; shift
fi
if (( opt_proj && opt_zone )); then
        opt_proj=0
fi
if (( opt_name || opt_pid )); then
	filter=1
fi
if (( opt_clear )); then
        clearstr=`clear`
else
        clearstr=.
fi



#################################
# --- Main Program, DTrace ---
#
/usr/sbin/dtrace -n '
 /*
  * Command line arguments
  */
 inline int OPT_def 	= '$opt_def';
 inline int OPT_proj 	= '$opt_proj';
 inline int OPT_zone 	= '$opt_zone';
 inline int OPT_clear 	= '$opt_clear';
 inline int OPT_bytes 	= '$opt_bytes';
 inline int OPT_count	= '$opt_count';
 inline int OPT_name 	= '$opt_name';
 inline int OPT_pid 	= '$opt_pid';
 inline int OPT_top 	= '$opt_top';
 inline int INTERVAL 	= '$interval';
 inline int COUNTER 	= '$count';
 inline int FILTER 	= '$filter';
 inline int TOP 	= '$top';
 inline int PID		= '$pid';
 inline string NAME 	= "'$pname'";
 inline string CLEAR 	= "'$clearstr'";

 #pragma D option quiet

 /*
  * Print header
  */
 dtrace:::BEGIN
 {
        /* starting values */
        counts = COUNTER;
        secs = INTERVAL;
        app_r = 0;
        app_w = 0;

        printf("Sampling... Please wait.\n");
 }

 /*
  * Check event is being traced
  */
 sysinfo:::readch,
 sysinfo:::writech
 /pid != $pid/
 {
	/* default is to trace unless filtering, */
	this->ok = FILTER ? 0 : 1;

	/* check each filter, */
	(OPT_name == 1 && NAME == execname)? this->ok = 1 : 1;
	(OPT_pid == 1 && PID == pid) ? this->ok = 1 : 1;
 }

 /*
  * Increment tallys
  */
 sysinfo:::readch
 /this->ok/
 {
	app_r += arg0;
 }
 sysinfo:::writech
 /this->ok/
 {
	app_w += arg0;
 }

 /*
  * Process event
  */
 sysinfo:::readch,
 sysinfo:::writech
 /this->ok/
 {
	/* choose statistic to track */
	this->value = OPT_bytes ? arg0 : 1;

	/*
	 * Save details
	 */
	OPT_def ? @out[uid, pid, ppid, execname,
	    probename == "readch" ? "R" : "W"] = sum(this->value) : 1;
	OPT_proj ? @out[curpsinfo->pr_projid, pid, ppid, execname,
	    probename == "readch" ? "R" : "W"] = sum(this->value) : 1;
	OPT_zone ? @out[curpsinfo->pr_zoneid, pid, ppid, execname,
	    probename == "readch" ? "R" : "W"] = sum(this->value) : 1;

	this->ok = 0;
 }

 /*
  * Timer
  */
 profile:::tick-1sec
 {
	secs--;
 }

 /*
  * Print Report
  */
 profile:::tick-1sec
 /secs == 0/
 {
	/* fetch 1 min load average */
	this->load1a  = `hp_avenrun[0] / 65536;
	this->load1b  = ((`hp_avenrun[0] % 65536) * 100) / 65536;

	/* convert counters to Kb */
	app_r /= 1024;
	app_w /= 1024;

	/* print status */
	OPT_clear ? printf("%s", CLEAR) : 1;
	printf("%Y,  load: %d.%02d,  app_r: %6d Kb,  app_w: %6d Kb\n\n",
	    walltimestamp, this->load1a, this->load1b, app_r, app_w);

	/* print headers */
	OPT_def  ? printf("  UID ") : 1;
	OPT_proj ? printf(" PROJ ") : 1;
	OPT_zone ? printf(" ZONE ") : 1;
	printf("%6s %6s %-16s %1s",
	    "PID", "PPID", "CMD", "D");
	OPT_bytes ? printf(" %16s\n", "BYTES") : 1;
	OPT_count ? printf(" %16s\n", "COUNT") : 1;

	/* truncate to top lines if needed */
	OPT_top ? trunc(@out, TOP) : 1;

	/* print data */
	printa("%5d %6d %6d %-16s %1s %16@d\n", @out);
	printf("\n");

	/* clear data */
	trunc(@out);
	app_r = 0;
	app_w = 0;
	secs = INTERVAL;
	counts--;
 }

 /*
  * End of program
  */
 profile:::tick-1sec
 /counts == 0/
 {
	exit(0);
 }

 /*
  * Cleanup for Ctrl-C
  */
 dtrace:::END
 {
	trunc(@out);
 }
'

##############################################################
#!/usr/bin/ksh
#
# tcpsnoop - snoop TCP network packets by process.
#            Written using DTrace (Solaris 10 3/05)
#
# This analyses TCP network packets and prints the responsible PID and UID,
# plus standard details such as IP address and port. This captures traffic
# of newly created TCP connections that were established while this program
# was running. It can help identify which processes is causing TCP traffic.
#
# 03-Dec-2005, ver 0.80        (check for newer versions)
#
# USAGE:       tcpsnoop [-a|hjsvZ] [-n name] [-p pid]
#
#		-a             # print all data
#		-j             # print project ID
#		-s             # print time, us
#		-v             # print time, string
#		-Z             # print zone ID
#		-n name        # command name to snoop
#		-p pid         # PID to snoop
#	eg,
#		tcpsnoop -v              # human readable timestamps
#		tcpsnoop -Z              # print zonename
#		tcpsnoop -n sshd         # snoop sshd traffic only
#
# FIELDS:
#		UID     	user ID
#		PID     	process ID
#		CMD     	command
#		LADDR		local IP address
#		RADDR		remote IP address
#		LPORT		local port number
#		RPORT		remote port number
#		DR      	direction
#		SIZE    	packet size, bytes
#		TIME    	timestamp, us
#		STRTIME    	human readable timestamp, string
#		ZONE    	zone ID
#		PROJ    	project ID
#
# SEE ALSO: snoop -rS
#
# COPYRIGHT: Copyright (c) 2005 Brendan Gregg.
#
# CDDL HEADER START
#
#  The contents of this file are subject to the terms of the
#  Common Development and Distribution License, Version 1.0 only
#  (the "License").  You may not use this file except in compliance
#  with the License.
#
#  You can obtain a copy of the license at Docs/cddl1.txt
#  or http://www.opensolaris.org/os/licensing.
#  See the License for the specific language governing permissions
#  and limitations under the License.
#
# CDDL HEADER END
#
# Author: Brendan Gregg  [Sydney, Australia]
#
# TODO: IPv6
#
# CODE:
#  The FILTER syntax matches on packets rather than initial
#  connections, so that it can follow inetd connections properly.
#
# 09-Jul-2004  Brendan Gregg	Created this.
# 12-Mar-2005     "      "	Changed probes, size info now printed.
# 02-Jul-2005     "      "	Many more probes. Renamed "tcpsnoop.d".
# 04-Jul-2005     "      "	Now wrapped in shell, called "tcpsnoop".
# 03-Dec-2005	  "	 "	Fixed tcp_accept_finish bug, now 100% correct
#				execname. Thanks Kias Belgaied for expertise.
#

##############################
# --- Process Arguments ---
#

### default variables
opt_name=0; opt_time=0; opt_timestr=0; filter=0; pname=.
opt_zone=0; opt_proj=0; opt_pid=0; pid=0

### process options
while getopts ahjsvZn:p: name
do
	case $name in
	a)      opt_time=1; opt_timestr=1; opt_zone=1; opt_proj=1 ;;
	n)      opt_name=1; pname=$OPTARG ;;
	p)      opt_pid=1; pid=$OPTARG ;;
	j)      opt_proj=1 ;;
	s)      opt_time=1 ;;
	v)      opt_timestr=1 ;;
	Z)      opt_zone=1 ;;
	h|?)    cat <<-END >&2
		USAGE: tcpsnoop [-a|hjsvZ] [-n name] [-p pid]
		       tcpsnoop                # default output
		                -a             # print all data
		                -j             # print project ID
		                -s             # print start time, us
		                -v             # print start time, string
		                -Z             # print zonename
		                -n name        # command name to snoop
		                -p pid         # PID to snoop
		  eg,
		      tcpsnoop -v              # human readable timestamps
		      tcpsnoop -Z              # print zonename
		      tcpsnoop -n sshd         # snoop sshd traffic only
		END
		exit 1
	esac
done

### option logic
if (( opt_name || opt_pid )); then
	filter=1
fi

#################################
# --- Main Program, DTrace ---
#
/usr/sbin/dtrace -Cs <( print -r '
 /*
  * Command line arguments
  */
 inline int OPT_name    = '$opt_name';
 inline int OPT_pid     = '$opt_pid';
 inline int OPT_time    = '$opt_time';
 inline int OPT_timestr = '$opt_timestr';
 inline int OPT_zone    = '$opt_zone';
 inline int OPT_proj    = '$opt_proj';
 inline int PID         = '$pid';
 inline int FILTER      = '$filter';
 inline string NAME     = "'$pname'";

#pragma D option quiet
#pragma D option switchrate=10hz

#include <sys/file.h>
#include <inet/common.h>
#include <sys/byteorder.h>
#include <sys/socket.h>
#include <sys/socketvar.h>

/*
 * Print header
 */
dtrace:::BEGIN
{
	/* print optional headers */
	OPT_time    ? printf("%-14s ", "TIME") : 1;
	OPT_timestr ? printf("%-20s ", "STRTIME") : 1;
	OPT_zone    ? printf("%4s ", "ZONE") : 1;
	OPT_proj    ? printf("%4s ", "PROJ") : 1;

	/* print main headers */
	printf("%5s %6s %-15s %5s %2s %-15s %5s %5s %s\n",
	    "UID", "PID", "LADDR", "LPORT", "DR", "RADDR", "RPORT",
	    "SIZE", "CMD");
}


/*
 * TCP Process inbound connections
 */
fbt:sockfs:sotpi_accept:entry
/(arg1 & FREAD) && (arg1 & FWRITE) && (args[0]->so_state & SS_TCP_FAST_ACCEPT)/
{
	self->sop = args[0];
}

fbt:sockfs:sotpi_create:return
/self->sop/
{
	self->nsop = (struct sonode *)arg1;
}

fbt:sockfs:sotpi_accept:return
/self->nsop/
{
	this->tcpp = (tcp_t *)self->nsop->so_priv;
	self->connp = (conn_t *)this->tcpp->tcp_connp;
	tname[(int)self->connp] = execname;
	tpid[(int)self->connp] = pid;
	tuid[(int)self->connp] = uid;
}

fbt:sockfs:sotpi_accept:return
{
	self->nsop = 0;
	self->sop = 0;
}

/*
 * TCP Process outbound connections
 */
fbt:ip:tcp_connect:entry
{
	this->tcpp = (tcp_t *)arg0;
	self->connp = (conn_t *)this->tcpp->tcp_connp;
	tname[(int)self->connp] = execname;
	tpid[(int)self->connp] = pid;
	tuid[(int)self->connp] = uid;
	OPT_proj ? tproj[(int)self->connp] = curpsinfo->pr_projid : 1;
}

/*
 * TCP Data translations
 */
fbt:sockfs:sotpi_accept:return,
fbt:ip:tcp_connect:return
/self->connp/
{
	/* fetch ports */
#if defined(_BIG_ENDIAN)
	self->lport = self->connp->u_port.tcpu_ports.tcpu_lport;
	self->fport = self->connp->u_port.tcpu_ports.tcpu_fport;
#else
	self->lport = BSWAP_16(self->connp->u_port.tcpu_ports.tcpu_lport);
	self->fport = BSWAP_16(self->connp->u_port.tcpu_ports.tcpu_fport);
#endif

	/* fetch IPv4 addresses */
	this->fad12 =
	    (int)self->connp->connua_v6addr.connua_faddr._S6_un._S6_u8[12];
	this->fad13 =
	    (int)self->connp->connua_v6addr.connua_faddr._S6_un._S6_u8[13];
	this->fad14 =
	    (int)self->connp->connua_v6addr.connua_faddr._S6_un._S6_u8[14];
	this->fad15 =
	    (int)self->connp->connua_v6addr.connua_faddr._S6_un._S6_u8[15];
	this->lad12 =
	    (int)self->connp->connua_v6addr.connua_laddr._S6_un._S6_u8[12];
	this->lad13 =
	    (int)self->connp->connua_v6addr.connua_laddr._S6_un._S6_u8[13];
	this->lad14 =
	    (int)self->connp->connua_v6addr.connua_laddr._S6_un._S6_u8[14];
	this->lad15 =
	    (int)self->connp->connua_v6addr.connua_laddr._S6_un._S6_u8[15];

	/* convert type for use with lltostr() */
	this->fad12 = this->fad12 < 0 ? 256 + this->fad12 : this->fad12;
	this->fad13 = this->fad13 < 0 ? 256 + this->fad13 : this->fad13;
	this->fad14 = this->fad14 < 0 ? 256 + this->fad14 : this->fad14;
	this->fad15 = this->fad15 < 0 ? 256 + this->fad15 : this->fad15;
	this->lad12 = this->lad12 < 0 ? 256 + this->lad12 : this->lad12;
	this->lad13 = this->lad13 < 0 ? 256 + this->lad13 : this->lad13;
	this->lad14 = this->lad14 < 0 ? 256 + this->lad14 : this->lad14;
	this->lad15 = this->lad15 < 0 ? 256 + this->lad15 : this->lad15;

	/* stringify addresses */
	self->faddr = strjoin(lltostr(this->fad12), ".");
	self->faddr = strjoin(self->faddr, strjoin(lltostr(this->fad13), "."));
	self->faddr = strjoin(self->faddr, strjoin(lltostr(this->fad14), "."));
	self->faddr = strjoin(self->faddr, lltostr(this->fad15 + 0));
	self->laddr = strjoin(lltostr(this->lad12), ".");
	self->laddr = strjoin(self->laddr, strjoin(lltostr(this->lad13), "."));
	self->laddr = strjoin(self->laddr, strjoin(lltostr(this->lad14), "."));
	self->laddr = strjoin(self->laddr, lltostr(this->lad15 + 0));

	/* fix direction and save values */
	tladdr[(int)self->connp] = self->laddr;
	tfaddr[(int)self->connp] = self->faddr;
	tlport[(int)self->connp] = self->lport;
	tfport[(int)self->connp] = self->fport;

	/* all systems go */
	tok[(int)self->connp] = 1;
}

/*
 * TCP Clear connp
 */
fbt:ip:tcp_get_conn:return
{
	/* Q_TO_CONN */
	this->connp = (conn_t *)arg1;
	tok[(int)this->connp] = 0;
	tpid[(int)this->connp] = 0;
	tuid[(int)this->connp] = 0;
	tname[(int)this->connp] = 0;
	tproj[(int)this->connp] = 0;
}

/*
 * TCP Process "port closed"
 */
fbt:ip:tcp_xmit_early_reset:entry
/FILTER == 0/
{
	this->queuep = (queue_t *)`tcp_g_q; /* ` */
	this->connp = (conn_t *)this->queuep->q_ptr;
	this->tcpp = (tcp_t *)this->connp->conn_tcp;
	self->zoneid = this->connp->conn_zoneid;

	/* split addresses */
	this->ipha = (ipha_t *)args[1]->b_rptr;
	this->fad15 = (this->ipha->ipha_src & 0xff000000) >> 24;
	this->fad14 = (this->ipha->ipha_src & 0x00ff0000) >> 16;
	this->fad13 = (this->ipha->ipha_src & 0x0000ff00) >> 8;
	this->fad12 = (this->ipha->ipha_src & 0x000000ff);
	this->lad15 = (this->ipha->ipha_dst & 0xff000000) >> 24;
	this->lad14 = (this->ipha->ipha_dst & 0x00ff0000) >> 16;
	this->lad13 = (this->ipha->ipha_dst & 0x0000ff00) >> 8;
	this->lad12 = (this->ipha->ipha_dst & 0x000000ff);

	/* stringify addresses */
	self->faddr = strjoin(lltostr(this->fad12), ".");
	self->faddr = strjoin(self->faddr, strjoin(lltostr(this->fad13), "."));
	self->faddr = strjoin(self->faddr, strjoin(lltostr(this->fad14), "."));
	self->faddr = strjoin(self->faddr, lltostr(this->fad15 + 0));
	self->laddr = strjoin(lltostr(this->lad12), ".");
	self->laddr = strjoin(self->laddr, strjoin(lltostr(this->lad13), "."));
	self->laddr = strjoin(self->laddr, strjoin(lltostr(this->lad14), "."));
	self->laddr = strjoin(self->laddr, lltostr(this->lad15 + 0));

	self->reset = 1;
}

/*
 * TCP Fetch "port closed" ports
 */
fbt:ip:tcp_xchg:entry
/self->reset/
{
#if defined(_BIG_ENDIAN)
	self->lport = (uint16_t)arg0;
	self->fport = (uint16_t)arg1;
#else
	self->lport = BSWAP_16((uint16_t)arg0);
	self->fport = BSWAP_16((uint16_t)arg1);
#endif
	self->lport = BE16_TO_U16(arg0);
	self->fport = BE16_TO_U16(arg1);
}

/*
 * TCP Print "port closed"
 */
fbt:ip:tcp_xmit_early_reset:return
/FILTER == 0/
{
	self->name = "<closed>";
	self->pid = 0;
	self->uid = 0;
	self->proj = 0;
	self->size = 54;	/* should check trailers */
	self->dir = "<-";
	OPT_time ? printf("%-14d ", timestamp/1000) : 1;
	OPT_timestr ? printf("%-20Y ", walltimestamp) : 1;
	OPT_zone ? printf("%4d ", self->zoneid) : 1;
	OPT_proj ? printf("%4d ", self->proj) : 1;
        printf("%5d %6d %-15s %5d %2s %-15s %5d %5d %s\n",
	    self->uid, self->pid, self->laddr, self->lport, self->dir,
	    self->faddr, self->fport, self->size, self->name);
	self->dir = "->";
	OPT_time ? printf("%-14d ", timestamp/1000) : 1;
	OPT_timestr ? printf("%-20Y ", walltimestamp) : 1;
	OPT_zone ? printf("%4d ", self->zoneid) : 1;
	OPT_proj ? printf("%4d ", self->proj) : 1;
        printf("%5d %6d %-15s %5d %2s %-15s %5d %5d %s\n",
	    self->uid, self->pid, self->laddr, self->lport, self->dir,
	    self->faddr, self->fport, self->size, self->name);
	self->reset = 0;
	self->size = 0;
	self->name = 0;
	self->zoneid = 0;
}

/*
 * TCP Process Write
 */
fbt:ip:tcp_send_data:entry
{
	self->conn_p = (conn_t *)args[0]->tcp_connp;
}

fbt:ip:tcp_send_data:entry
/tok[(int)self->conn_p]/
{
        self->dir = "->";
        self->size = msgdsize(args[2]) + 14;	/* should check trailers */
	self->uid = tuid[(int)self->conn_p];
	self->laddr = tladdr[(int)self->conn_p];
	self->faddr = tfaddr[(int)self->conn_p];
	self->lport = tlport[(int)self->conn_p];
	self->fport = tfport[(int)self->conn_p];
	OPT_proj ? self->proj = tproj[(int)self->conn_p] : 1;
	self->zoneid = self->conn_p->conn_zoneid;
        self->ok = 2;

	/* follow inetd -> in.* transitions */
	self->name = pid && (tname[(int)self->conn_p] == "inetd") ?
	    execname : tname[(int)self->conn_p];
	self->pid = pid && (tname[(int)self->conn_p] == "inetd") ?
	    pid : tpid[(int)self->conn_p];
	tname[(int)self->conn_p] = self->name;
	tpid[(int)self->conn_p] = self->pid;
}

/*
 * TCP Process Read
 */
fbt:ip:tcp_rput_data:entry
{
	self->conn_p = (conn_t *)arg0;
        self->size = msgdsize(args[1]) + 14;	/* should check trailers */
}

fbt:ip:tcp_rput_data:entry
/tok[(int)self->conn_p]/
{
	self->dir = "<-";
	self->uid = tuid[(int)self->conn_p];
	self->laddr = tladdr[(int)self->conn_p];
	self->faddr = tfaddr[(int)self->conn_p];
	self->lport = tlport[(int)self->conn_p];
	self->fport = tfport[(int)self->conn_p];
	OPT_proj ? self->proj = tproj[(int)self->conn_p] : 1;
	self->zoneid = self->conn_p->conn_zoneid;
	self->ok = 2;

	/* follow inetd -> in.* transitions */
	self->name = pid && (tname[(int)self->conn_p] == "inetd") ?
	    execname : tname[(int)self->conn_p];
	self->pid = pid && (tname[(int)self->conn_p] == "inetd") ?
	    pid : tpid[(int)self->conn_p];
	tname[(int)self->conn_p] = self->name;
	tpid[(int)self->conn_p] = self->pid;
}

/*
 * TCP Complete printing outbound handshake
 */
fbt:ip:tcp_connect:return
/self->connp/
{
	self->name = tname[(int)self->connp];
	self->pid = tpid[(int)self->connp];
	self->uid = tuid[(int)self->connp];
	self->zoneid = self->connp->conn_zoneid;
	OPT_proj ? self->proj = tproj[(int)self->connp] : 1;
	self->size = 54;	/* should check trailers */
	self->dir = "->";
}

fbt:ip:tcp_connect:return
/(self->connp) &&
 ((FILTER == 0) ||
 (OPT_pid && self->pid == PID) ||
 (OPT_name && self->name == NAME))/
{
	/* this packet occured before connp was fully established */
	OPT_time ? printf("%-14d ", timestamp/1000) : 1;
	OPT_timestr ? printf("%-20Y ", walltimestamp) : 1;
	OPT_zone ? printf("%4d ", self->zoneid) : 1;
	OPT_proj ? printf("%4d ", self->proj) : 1;
        printf("%5d %6d %-15s %5d %2s %-15s %5d %5d %s\n",
	    self->uid, self->pid, self->laddr, self->lport, self->dir,
	    self->faddr, self->fport, self->size, self->name);
}

/*
 * TCP Complete printing inbound handshake
 */
fbt:sockfs:sotpi_accept:return
/self->connp/
{
	self->name = tname[(int)self->connp];
	self->pid = tpid[(int)self->connp];
	self->uid = tuid[(int)self->connp];
	self->zoneid = self->connp->conn_zoneid;
	OPT_proj ? self->proj = tproj[(int)self->connp] : 1;
	self->size = 54;	/* should check trailers */
	self->dir = "<-";
}

fbt:sockfs:sotpi_accept:return
/(self->connp) &&
 ((FILTER == 0) ||
 (OPT_pid && self->pid == PID) ||
 (OPT_name && self->name == NAME))/
{
	/* these packets occured before connp was fully established */
	OPT_time ? printf("%-14d ", timestamp/1000) : 1;
	OPT_timestr ? printf("%-20Y ", walltimestamp) : 1;
	OPT_zone ? printf("%4d ", self->zoneid) : 1;
	OPT_proj ? printf("%4d ", self->proj) : 1;
        printf("%5d %6d %-15s %5d %2s %-15s %5d %5d %s\n",
	    self->uid, self->pid, self->laddr, self->lport, self->dir,
	    self->faddr, self->fport, self->size, self->name);
	self->dir = "->";
	OPT_time ? printf("%-14d ", timestamp/1000) : 1;
	OPT_timestr ? printf("%-20Y ", walltimestamp) : 1;
	OPT_zone ? printf("%4d ", self->zoneid) : 1;
	OPT_proj ? printf("%4d ", self->proj) : 1;
        printf("%5d %6d %-15s %5d %2s %-15s %5d %5d %s\n",
	    self->uid, self->pid, self->laddr, self->lport, self->dir,
	    self->faddr, self->fport, self->size, self->name);
	self->dir = "<-";
	OPT_time ? printf("%-14d ", timestamp/1000) : 1;
	OPT_timestr ? printf("%-20Y ", walltimestamp) : 1;
	OPT_zone ? printf("%4d ", self->zoneid) : 1;
	OPT_proj ? printf("%4d ", self->proj) : 1;
        printf("%5d %6d %-15s %5d %2s %-15s %5d %5d %s\n",
	    self->uid, self->pid, self->laddr, self->lport, self->dir,
	    self->faddr, self->fport, self->size, self->name);
}

/*
 * Print output
 */
fbt:ip:tcp_send_data:entry,
fbt:ip:tcp_rput_data:entry
/(self->ok == 2) &&
 ((FILTER == 0) ||
 (OPT_pid && self->pid == PID) ||
 (OPT_name && self->name == NAME))/
{
	/* print optional fields */
	OPT_time ? printf("%-14d ", timestamp/1000) : 1;
	OPT_timestr ? printf("%-20Y ", walltimestamp) : 1;
	OPT_zone ? printf("%4d ", self->zoneid) : 1;
	OPT_proj ? printf("%4d ", self->proj) : 1;

	/* print output line */
        printf("%5d %6d %-15s %5d %2s %-15s %5d %5d %s\n",
	    self->uid, self->pid, self->laddr, self->lport, self->dir,
	    self->faddr, self->fport, self->size, self->name);
}

/*
 * TCP Clear connect variables
 */
fbt:sockfs:sotpi_accept:return,
fbt:ip:tcp_connect:return
/self->connp/
{
	self->faddr = 0;
	self->laddr = 0;
	self->fport = 0;
	self->lport = 0;
	self->connp = 0;
	self->name = 0;
	self->pid = 0;
	self->uid = 0;
}

/*
 * TCP Clear r/w variables
 */
fbt:ip:tcp_send_data:entry,
fbt:ip:tcp_rput_data:entry
{
	self->ok = 0;
	self->dir = 0;
	self->uid = 0;
	self->pid = 0;
	self->size = 0;
	self->name = 0;
	self->lport = 0;
	self->fport = 0;
	self->laddr = 0;
	self->faddr = 0;
	self->conn_p = 0;
	self->zoneid = 0;
	self->proj = 0;
}
')
##############################################################
#!/usr/bin/ksh
#
# rwsnoop - snoop read/write events.
#           Written using DTrace (Solaris 10 3/05).
#
# This is measuring reads and writes at the application level. This matches
# the syscalls read, write, pread and pwrite.
#
# 17-Sep-2005, ver 0.75		(check for newer versions)
#
# USAGE:	rwsnoop [-jPtvZ] [-n name] [-p pid]
#
#		rwsnoop		# default output
#
#		-j		# print project ID
#		-P		# print parent process ID
#		-t		# print timestamp, us
#		-v		# print time, string
#		-Z		# print zone ID
#		-n name		# this process name only
#		-p PID		# this PID only
#	eg,
#		rwsnoop -Z		# print zone ID
#		rwsnoop -n bash 	# monitor processes named "bash"
#		rwsnoop > out.txt	# recommended
#
# NOTE:
# 	rwsnoop usually prints plenty of output, which itself will cause
#	more output. It can be better to redirect the output of rwsnoop
#	to a file to prevent this.
#
# FIELDS:
#		TIME		Timestamp, us
#		TIMESTR		Time, string
#		ZONE		Zone ID
#		PROJ		Project ID
#		UID		User ID
#		PID		Process ID
#		PPID		Parent Process ID
#		CMD		Process name
#		D		Direction, Read or Write
#		BYTES		Total bytes during sample, -1 for error
#		FILE		Filename, if file based
#
# Reads and writes that are not file based, for example with sockets, will
# print "<unknown>" as the filename.
#
# SEE ALSO:	rwtop
#
# COPYRIGHT: Copyright (c) 2005 Brendan Gregg.
#
# CDDL HEADER START
#
#  The contents of this file are subject to the terms of the
#  Common Development and Distribution License, Version 1.0 only
#  (the "License").  You may not use this file except in compliance
#  with the License.
#
#  You can obtain a copy of the license at Docs/cddl1.txt
#  or http://www.opensolaris.org/os/licensing.
#  See the License for the specific language governing permissions
#  and limitations under the License.
#
# CDDL HEADER END
#
# TODO:
#  Track readv and writev.
#
# Author: Brendan Gregg  [Sydney, Australia]
#
# 24-Jul-2005   Brendan Gregg   Created this.
# 17-Sep-2005	   "      "	Increased switchrate.
#


##############################
# --- Process Arguments ---
#

### default variables
opt_name=0; opt_pid=0; opt_proj=0; opt_zone=0; opt_time=0; opt_timestr=0
opt_bytes=1; filter=0; pname=.; pid=0; opt_ppid=0

### process options
while getopts n:Pp:jtvZ name
do
	case $name in
	n)	opt_name=1; pname=$OPTARG ;;
	p)	opt_pid=1; pid=$OPTARG ;;
	P)	opt_ppid=1 ;;
	j)	opt_proj=1 ;;
	t)	opt_time=1 ;;
	v)	opt_timestr=1 ;;
	Z)	opt_zone=1 ;;
	h|?)	cat <<-END >&2
		USAGE: rwsnoop [-jPtvZ] [-n name] [-p pid]

		                -j       # print project ID
		                -P       # print parent process ID
		                -t       # print timestamp, us
		                -v       # print time, string
		                -Z       # print zone ID
		                -n name  # this process name only
		                -p PID   # this PID only
		   eg,
		        rwsnoop          # default output
		        rwsnoop -Z       # print zone ID
		        rwsnoop -n bash  # monitor processes named "bash"
		END
		exit 1
	esac
done

shift $(( $OPTIND - 1 ))

### option logic
if (( opt_name || opt_pid )); then
	filter=1
fi



#################################
# --- Main Program, DTrace ---
#
/usr/sbin/dtrace -n '
 /*
  * Command line arguments
  */
 inline int OPT_proj 	= '$opt_proj';
 inline int OPT_zone 	= '$opt_zone';
 inline int OPT_bytes 	= '$opt_bytes';
 inline int OPT_name 	= '$opt_name';
 inline int OPT_ppid 	= '$opt_ppid';
 inline int OPT_pid 	= '$opt_pid';
 inline int OPT_time 	= '$opt_time';
 inline int OPT_timestr	= '$opt_timestr';
 inline int FILTER 	= '$filter';
 inline int PID		= '$pid';
 inline string NAME 	= "'$pname'";

 #pragma D option quiet
 #pragma D option switchrate=10hz

 /*
  * Print header
  */
 dtrace:::BEGIN
 {
	/* print header */
	OPT_time    ? printf("%-14s ", "TIME") : 1;
	OPT_timestr ? printf("%-20s ", "TIMESTR") : 1;
	OPT_proj    ? printf("%5s ", "PROJ") : 1;
	OPT_zone    ? printf("%5s ", "ZONE") : 1;
	OPT_ppid    ? printf("%6s ", "PPID") : 1;
	printf("%5s %6s %-12s %1s %7s %s\n",
	    "UID", "PID", "CMD", "D", "BYTES", "FILE");
 }

 /*
  * Check event is being traced
  */
 syscall::*read:entry,
 syscall::*write:entry
 /pid != $pid/
 {
	/* default is to trace unless filtering, */
	self->ok = FILTER ? 0 : 1;

	/* check each filter, */
	(OPT_name == 1 && NAME == execname)? self->ok = 1 : 1;
	(OPT_pid == 1 && PID == pid) ? self->ok = 1 : 1;

	/* save file descriptor */
	self->fd = self->ok ? arg0 : 0;
 }

 /*
  * Save read details
  */
 syscall::*read:return
 /self->ok/
 {
	self->rw = "R";
	self->size = arg0;
 }

 /*
  * Save write details
  */
 syscall::*write:entry
 /self->ok/
 {
	self->rw = "W";
	self->size = arg2;
 }

 /*
  * Process event
  */
 syscall::*read:return,
 syscall::*write:entry
 /self->ok/
 {
	/*
	 * Fetch filename
	 */
	this->filistp = curthread->t_procp->p_user.u_finfo.fi_list;
	this->ufentryp = (uf_entry_t *)((uint64_t)this->filistp +
	    (uint64_t)self->fd * (uint64_t)sizeof(uf_entry_t));
	this->filep = this->ufentryp->uf_file;
	this->vnodep = this->filep != 0 ? this->filep->f_vnode : 0;
	self->vpath = this->vnodep ? (this->vnodep->v_path != 0 ?
	    cleanpath(this->vnodep->v_path) : "<unknown>") : "<unknown>";

	/*
	 * Print details
	 */
	OPT_time    ? printf("%-14d ", timestamp / 1000) : 1;
	OPT_timestr ? printf("%-20Y ", walltimestamp) : 1;
	OPT_proj    ? printf("%5d ", curpsinfo->pr_projid) : 1;
	OPT_zone    ? printf("%5d ", curpsinfo->pr_zoneid) : 1;
	OPT_ppid    ? printf("%6d ", ppid) : 1;
	printf("%5d %6d %-12.12s %1s %7d %s\n",
	    uid, pid, execname, self->rw, (int)self->size, self->vpath);

	self->ok = 0;
	self->fd = 0;
	self->rw = 0;
	self->size = 0;
	self->vpath = 0;
 }
'
##############################################################
#!/usr/bin/sh
#
# opensnoop - snoop file opens as they occur.
#             Written using DTrace (Solaris 10 3/05).
#
# 12-Jan-2006, ver 1.60
#
# USAGE:	opensnoop [-a|-A|-ceghsvxZ] [-f pathname] [-n name] [-p PID]
#
#		opensnoop	# default output
#
#		-a		# print most data
#		-A		# dump all data, space delimited
#		-c		# print cwd of process
#		-e		# print errno value
#		-g		# print command arguments
#		-s		# print start time, us
#		-v		# print start time, string
#		-x		# only print failed opens
#		-Z		# print zonename
#		-f pathname	# file pathname to snoop
#		-n name		# command name to snoop
#		-p PID		# process ID to snoop
#	eg,
#		opensnoop -v			# human readable timestamps
#		opensnoop -e			# see error codes
#		opensnoop -f /etc/passwd	# snoop this file only
#
# FIELDS:
#		ZONE		Zone name
#		UID		User ID
#		PID		Process ID
#		PPID		Parent Process ID
#		FD		file descriptor (-1 for error)
#		ERR		errno value (see /usr/include/sys/errno.h)
#		CWD		print current working directory of process
#		PATH		pathname for file open
#		COMM		command name for the process
#		ARGS		argument listing for the process
#		TIME		timestamp for the open event, us
#		STRTIME		timestamp for the open event, string
#
# SEE ALSO: truss, BSM auditing.
#
# COPYRIGHT: Copyright (c) 2006 Brendan Gregg.
#
# CDDL HEADER START
#
#  The contents of this file are subject to the terms of the
#  Common Development and Distribution License, Version 1.0 only
#  (the "License").  You may not use this file except in compliance
#  with the License.
#
#  You can obtain a copy of the license at Docs/cddl1.txt
#  or http://www.opensolaris.org/os/licensing.
#  See the License for the specific language governing permissions
#  and limitations under the License.
#
# CDDL HEADER END
#
# Author: Brendan Gregg  [Sydney, Australia]
#
# 09-May-2004	Brendan Gregg	Created this.
# 21-Jan-2005	   "	  "	Wrapped in sh to provide options.
# 08-May-2005	   "      "	Rewritten for performance.
# 14-May-2005	   "      "	Added errno.
# 28-Jun-2005	   "      "	Added cwd, zonename.
# 17-Sep-2005	   "      "	Increased switchrate, fixed page fault bug.
# 16-Jan-2006	   "	  "	Added -n, -p.
#


##############################
# --- Process Arguments ---
#

### Default variables
opt_dump=0; opt_file=0; opt_time=0; opt_timestr=0; opt_args=0
opt_zone=0; opt_cwd=0; opt_failonly=0; opt_err=0; filter=0; pathname=.
opt_name=0; opt_pid=0; pname=.; pid=0

### Process options
while getopts aAcef:ghn:p:svxZ name
do
	case $name in
	a)	opt_time=1; opt_timestr=1; opt_args=1; opt_err=1 ;;
	A)	opt_dump=1 ;;
	c)	opt_cwd=1 ;;
	e)	opt_err=1 ;;
	g)	opt_args=1 ;;
	f)	opt_file=1; pathname=$OPTARG ;;
	n)	opt_name=1; pname=$OPTARG ;;
	p)	opt_pid=1; pid=$OPTARG ;;
	s)	opt_time=1 ;;
	v)	opt_timestr=1 ;;
	x)	opt_failonly=1 ;;
	Z)	opt_zone=1 ;;
	h|?)	cat <<-END >&2
		USAGE: opensnoop [-a|-A|-ceghsvxZ] [-f pathname]
		                 [-n name] [-p PID]
		       opensnoop                # default output
		                -a              # print most data
		                -A              # dump all data, space delimited
		                -c              # print cwd of process
		                -e              # print errno value
		                -g              # print command arguments
		                -s              # print start time, us
		                -v              # print start time, string
		                -x              # only print failed opens
		                -Z              # print zonename
		                -f pathname	# pathname name to snoop
		                -n name		# process name to snoop
		                -p PID		# process ID to snoop
		  eg,
		       opensnoop -v             # human readable timestamps
		       opensnoop -e             # see error codes
		       opensnoop -f /etc/motd   # snoop this file only
		END
		exit 1
	esac
done

### Option logic
if [ $opt_dump -eq 1 ]; then
	opt_zone=0; opt_cwd=0; opt_time=0; opt_timestr=0; opt_args=2
fi
if [ $opt_name -eq 1 -o $opt_pid -eq 1 ]; then
	filter=1
fi


#################################
# --- Main Program, DTrace ---
#
/usr/sbin/dtrace -n '
 /*
  * Command line arguments
  */
 inline int OPT_dump 	 = '$opt_dump';
 inline int OPT_file 	 = '$opt_file';
 inline int OPT_args 	 = '$opt_args';
 inline int OPT_cwd	 = '$opt_cwd';
 inline int OPT_err	 = '$opt_err';
 inline int OPT_zone 	 = '$opt_zone';
 inline int OPT_time 	 = '$opt_time';
 inline int OPT_timestr	 = '$opt_timestr';
 inline int OPT_failonly = '$opt_failonly';
 inline int OPT_pid	 = '$opt_pid';
 inline int OPT_name	 = '$opt_name';
 inline int FILTER 	 = '$filter';
 inline int PID		 = '$pid';
 inline string PATHNAME	 = "'$pathname'";
 inline string NAME	 = "'$pname'";

 #pragma D option quiet
 #pragma D option switchrate=10hz

 /*
  * Print header
  */
 dtrace:::BEGIN
 {
	/*
	 * ternary operators are used to improve performance.
	 * OPT_args is unusual in that it can have one of three values.
	 */

	/* print optional headers */
 	OPT_time ? printf("%-14s ", "TIME") : 1;
 	OPT_timestr ? printf("%-20s ", "STRTIME") : 1;
 	OPT_zone ? printf("%-10s ", "ZONE") : 1;

	/* print dump headers */
	OPT_dump ? printf("%s %s %s %s %s %s %s %s %s %s %s", "ZONE",
	    "TIME", "UID", "PID", "PPID", "COMM", "FD", "ERR", "CWD",
	    "PATH", "ARGS") : printf("%5s %6s ","UID","PID");

	/* print main headers */
	OPT_args == 0 ? printf("%-12s ", "COMM") : 1;
	OPT_dump == 0 ? printf("%3s ", "FD") : 1;
	OPT_err ? printf("%3s ", "ERR") : 1;
	OPT_cwd ? printf("%-20s ", "CWD") : 1;
	OPT_dump == 0 ? printf("%-20s ", "PATH") : 1;
	OPT_args == 1 ? printf("%s", "ARGS") : 1;
	printf("\n");
 }

 /*
  * Print open event
  */
 syscall::open:entry, syscall::open64:entry
 {
	/* save pathname */
	self->pathp = arg0;

	/* default is to trace unless filtering */
	self->ok = FILTER ? 0 : 1;

	/* check each filter */
	(OPT_name == 1 && NAME == execname) ? self->ok = 1 : 1;
	(OPT_pid == 1 && PID == pid) ? self->ok = 1 : 1;
	/* OPT_file is checked on return to ensure pathp is mapped */
 }

 syscall::open:return, syscall::open64:return
 /self->ok && (! OPT_failonly || (int)arg0 < 0) &&
 ((OPT_file == 0) || (OPT_file == 1 && PATHNAME == copyinstr(self->pathp)))/
 {
	/* print optional fields */
 	OPT_time ? printf("%-14d ", timestamp/1000) : 1;
 	OPT_timestr ? printf("%-20Y ", walltimestamp) : 1;
 	OPT_zone ? printf("%-10s ", zonename) : 1;

	/* print dump fields */
	OPT_dump ? printf("%s %d %d %d %d %s %d %d %s %s %S", zonename,
	    timestamp/1000, uid, pid, ppid, execname, (int)arg0, errno,
	    cwd, copyinstr(self->pathp), curpsinfo->pr_psargs) :
	    printf("%5d %6d ", uid, pid);

	/* print main fields */
	OPT_args == 0 ? printf("%-12s ", execname) : 1;
	OPT_dump == 0 ? printf("%3d ", (int)arg0) : 1;
	OPT_err ? printf("%3d ", errno) : 1;
	OPT_cwd ? printf("%-20s ", cwd) : 1;
	OPT_dump == 0 ? printf("%-20s ", copyinstr(self->pathp)) : 1;
	OPT_args == 1 ? printf("%S", curpsinfo->pr_psargs) : 1;
	printf("\n");

	/* cleanup */
	self->pathp = 0;
	self->ok = 0;
 }

 /*
  * Cleanup
  */
 syscall::open:return, syscall::open64:return
 /self->ok/
 {
	self->pathp = 0;
	self->ok = 0;
 }
'
##############################################################
#!/usr/bin/ksh
#
# tcptop - display top TCP network packets by process.
#          Written using DTrace (Solaris 10 3/05)
#
# This analyses TCP network packets and prints the responsible PID and UID,
# plus standard details such as IP address and port. This captures traffic
# of newly created TCP connections that were established while this program
# was running. It can help identify which processes is causing TCP traffic.
#
# 03-Dec-2005, ver 0.80        (check for newer versions)
#
# USAGE:	tcptop [-Ch] [-j|-Z] [interval [count]]
#
#		-C		# don't clear the screen
#		-j		# print project IDs
#		-Z		# print zone IDs
#
# FIELDS:
#		UID     	user ID
#		PID     	process ID
#		CMD     	command
#		LADDR		local IP address
#		RADDR		remote IP address
#		LPORT		local port number
#		RPORT		remote port number
#		SIZE    	packet size, bytes
#		load		1 min load average
#		TCPin		TCP inbound payload data
#		TCPout		TCP outbound payload data
#		ZONE    	zone ID
#		PROJ    	project ID
#
# SEE ALSO:	tcpsnoop
#
# COPYRIGHT: Copyright (c) 2005 Brendan Gregg.
#
# CDDL HEADER START
#
#  The contents of this file are subject to the terms of the
#  Common Development and Distribution License, Version 1.0 only
#  (the "License").  You may not use this file except in compliance
#  with the License.
#
#  You can obtain a copy of the license at Docs/cddl1.txt
#  or http://www.opensolaris.org/os/licensing.
#  See the License for the specific language governing permissions
#  and limitations under the License.
#
# CDDL HEADER END
#
# Author: Brendan Gregg  [Sydney, Australia]
#
# ToDo: IPv6
#
# 05-Jul-2005  Brendan Gregg	Created this.
# 03-Dec-2005	  "	 "	Fixed tcp_accept_finish bug, now 100% correct
#				execname. Thanks Kias Belgaied for expertise.
#

##############################
# --- Process Arguments ---
#

### default variables
opt_def=1; opt_clear=1; opt_zone=0; opt_proj=0; interval=5; count=-1

### process options
while getopts ChjZ name
do
	case $name in
	C)      opt_clear=0 ;;
	j)      opt_proj=1; opt_def=0 ;;
	Z)      opt_zone=1; opt_def=0 ;;
	h|?)    cat <<-END >&2
		USAGE: tcptop [-h] [-j|-Z] [interval [count]]
		       tcptop                  # default output
		                -C             # don't clear the screen
		                -j             # print project ID
		                -Z             # print zonename
		  eg,
		      tcptop                   # default is 5 sec interval
		      tcptop 2                 # 2 second interval
		      tcptop -C 1 10           # 10 x 1 sec samples, no clear
		END
		exit 1
	esac
done
shift $(( $OPTIND - 1 ))

### option logic
if [[ "$1" > 0 ]]; then
        interval=$1; shift
fi
if [[ "$1" > 0 ]]; then
        count=$1; shift
fi
if (( opt_proj && opt_zone )); then
	opt_proj=0
fi
if (( opt_clear )); then
	clearstr=`clear`
else
	clearstr=.
fi

#################################
# --- Main Program, DTrace ---
#
/usr/sbin/dtrace -Cs <( print -r '
 /*
  * Command line arguments
  */
 inline int OPT_def   = '$opt_def';
 inline int OPT_zone  = '$opt_zone';
 inline int OPT_proj  = '$opt_proj';
 inline int OPT_clear = '$opt_clear';
 inline int INTERVAL  = '$interval';
 inline int COUNTER   = '$count';
 inline string CLEAR  = "'$clearstr'";

#pragma D option quiet
#pragma D option switchrate=10hz

#include <sys/file.h>
#include <inet/common.h>
#include <sys/byteorder.h>
#include <sys/socket.h>
#include <sys/socketvar.h>

/*
 * Print header
 */
dtrace:::BEGIN
{
	/* starting values */
        counts = COUNTER;
        secs = INTERVAL;
	TCP_out = 0;
	TCP_in = 0;

	printf("Sampling... Please wait.\n");
}

/*
 * TCP Process inbound connections
 */
fbt:sockfs:sotpi_accept:entry
/(arg1 & FREAD) && (arg1 & FWRITE) && (args[0]->so_state & SS_TCP_FAST_ACCEPT)/
{
	self->sop = args[0];
}

fbt:sockfs:sotpi_create:return
/self->sop/
{
	self->nsop = (struct sonode *)arg1;
}

fbt:sockfs:sotpi_accept:return
/self->nsop/
{
	this->tcpp = (tcp_t *)self->nsop->so_priv;
	self->connp = (conn_t *)this->tcpp->tcp_connp;
	tname[(int)self->connp] = execname;
	tpid[(int)self->connp] = pid;
	tuid[(int)self->connp] = uid;
}

fbt:sockfs:sotpi_accept:return
{
	self->nsop = 0;
	self->sop = 0;
}

/*
 * TCP Process outbound connections
 */
fbt:ip:tcp_connect:entry
{
	this->tcpp = (tcp_t *)arg0;
	self->connp = (conn_t *)this->tcpp->tcp_connp;
	tname[(int)self->connp] = execname;
	tpid[(int)self->connp] = pid;
	tuid[(int)self->connp] = uid;
	OPT_proj ? tproj[(int)self->connp] = curpsinfo->pr_projid : 1;
}

/*
 * TCP Data translations
 */
fbt:sockfs:sotpi_accept:return,
fbt:ip:tcp_connect:return
/self->connp/
{
	/* fetch ports */
#if defined(_BIG_ENDIAN)
	self->lport = self->connp->u_port.tcpu_ports.tcpu_lport;
	self->fport = self->connp->u_port.tcpu_ports.tcpu_fport;
#else
	self->lport = BSWAP_16(self->connp->u_port.tcpu_ports.tcpu_lport);
	self->fport = BSWAP_16(self->connp->u_port.tcpu_ports.tcpu_fport);
#endif

	/* fetch IPv4 addresses */
	this->fad12 =
	    (int)self->connp->connua_v6addr.connua_faddr._S6_un._S6_u8[12];
	this->fad13 =
	    (int)self->connp->connua_v6addr.connua_faddr._S6_un._S6_u8[13];
	this->fad14 =
	    (int)self->connp->connua_v6addr.connua_faddr._S6_un._S6_u8[14];
	this->fad15 =
	    (int)self->connp->connua_v6addr.connua_faddr._S6_un._S6_u8[15];
	this->lad12 =
	    (int)self->connp->connua_v6addr.connua_laddr._S6_un._S6_u8[12];
	this->lad13 =
	    (int)self->connp->connua_v6addr.connua_laddr._S6_un._S6_u8[13];
	this->lad14 =
	    (int)self->connp->connua_v6addr.connua_laddr._S6_un._S6_u8[14];
	this->lad15 =
	    (int)self->connp->connua_v6addr.connua_laddr._S6_un._S6_u8[15];

	/* convert type for use with lltostr() */
	this->fad12 = this->fad12 < 0 ? 256 + this->fad12 : this->fad12;
	this->fad13 = this->fad13 < 0 ? 256 + this->fad13 : this->fad13;
	this->fad14 = this->fad14 < 0 ? 256 + this->fad14 : this->fad14;
	this->fad15 = this->fad15 < 0 ? 256 + this->fad15 : this->fad15;
	this->lad12 = this->lad12 < 0 ? 256 + this->lad12 : this->lad12;
	this->lad13 = this->lad13 < 0 ? 256 + this->lad13 : this->lad13;
	this->lad14 = this->lad14 < 0 ? 256 + this->lad14 : this->lad14;
	this->lad15 = this->lad15 < 0 ? 256 + this->lad15 : this->lad15;

	/* stringify addresses */
	self->faddr = strjoin(lltostr(this->fad12), ".");
	self->faddr = strjoin(self->faddr, strjoin(lltostr(this->fad13), "."));
	self->faddr = strjoin(self->faddr, strjoin(lltostr(this->fad14), "."));
	self->faddr = strjoin(self->faddr, lltostr(this->fad15 + 0));
	self->laddr = strjoin(lltostr(this->lad12), ".");
	self->laddr = strjoin(self->laddr, strjoin(lltostr(this->lad13), "."));
	self->laddr = strjoin(self->laddr, strjoin(lltostr(this->lad14), "."));
	self->laddr = strjoin(self->laddr, lltostr(this->lad15 + 0));

	/* fix direction and save values */
	tladdr[(int)self->connp] = self->laddr;
	tfaddr[(int)self->connp] = self->faddr;
	tlport[(int)self->connp] = self->lport;
	tfport[(int)self->connp] = self->fport;

	/* all systems go */
	tok[(int)self->connp] = 1;
}

/*
 * TCP Clear connp
 */
fbt:ip:tcp_get_conn:return
{
	/* Q_TO_CONN */
	this->connp = (conn_t *)arg1;
	tok[(int)this->connp] = 0;
	tpid[(int)this->connp] = 0;
	tuid[(int)this->connp] = 0;
	tname[(int)this->connp] = 0;
	tproj[(int)this->connp] = 0;
}

/*
 * TCP Process "port closed"
 */
fbt:ip:tcp_xmit_early_reset:entry
{
	this->queuep = (queue_t *)`tcp_g_q; /* ` */
	this->connp = (conn_t *)this->queuep->q_ptr;
	this->tcpp = (tcp_t *)this->connp->conn_tcp;
	self->zoneid = this->connp->conn_zoneid;

	/* split addresses */
	this->ipha = (ipha_t *)args[1]->b_rptr;
	this->fad15 = (this->ipha->ipha_src & 0xff000000) >> 24;
	this->fad14 = (this->ipha->ipha_src & 0x00ff0000) >> 16;
	this->fad13 = (this->ipha->ipha_src & 0x0000ff00) >> 8;
	this->fad12 = (this->ipha->ipha_src & 0x000000ff);
	this->lad15 = (this->ipha->ipha_dst & 0xff000000) >> 24;
	this->lad14 = (this->ipha->ipha_dst & 0x00ff0000) >> 16;
	this->lad13 = (this->ipha->ipha_dst & 0x0000ff00) >> 8;
	this->lad12 = (this->ipha->ipha_dst & 0x000000ff);

	/* stringify addresses */
	self->faddr = strjoin(lltostr(this->fad12), ".");
	self->faddr = strjoin(self->faddr, strjoin(lltostr(this->fad13), "."));
	self->faddr = strjoin(self->faddr, strjoin(lltostr(this->fad14), "."));
	self->faddr = strjoin(self->faddr, lltostr(this->fad15 + 0));
	self->laddr = strjoin(lltostr(this->lad12), ".");
	self->laddr = strjoin(self->laddr, strjoin(lltostr(this->lad13), "."));
	self->laddr = strjoin(self->laddr, strjoin(lltostr(this->lad14), "."));
	self->laddr = strjoin(self->laddr, lltostr(this->lad15 + 0));

	self->reset = 1;
}

/*
 * TCP Fetch "port closed" ports
 */
fbt:ip:tcp_xchg:entry
/self->reset/
{
#if defined(_BIG_ENDIAN)
	self->lport = (uint16_t)arg0;
	self->fport = (uint16_t)arg1;
#else
	self->lport = BSWAP_16((uint16_t)arg0);
	self->fport = BSWAP_16((uint16_t)arg1);
#endif
	self->lport = BE16_TO_U16(arg0);
	self->fport = BE16_TO_U16(arg1);
}

/*
 * TCP Print "port closed"
 */
fbt:ip:tcp_xmit_early_reset:return
{
	self->name = "<closed>";
	self->pid = 0;
	self->uid = 0;
	self->proj = 0;
	self->size = 54 * 2;	/* should check trailers */
	OPT_def ? @out[self->uid, self->pid, self->laddr, self->lport,
	    self->faddr, self->fport, self->name] = sum(self->size) : 1;
	OPT_zone ? @out[self->zoneid, self->pid, self->laddr, self->lport,
	    self->faddr, self->fport, self->name] = sum(self->size) : 1;
	OPT_proj ? @out[self->proj, self->pid, self->laddr, self->lport,
	    self->faddr, self->fport, self->name] = sum(self->size) : 1;
	self->reset = 0;
	self->size = 0;
	self->name = 0;
}

/*
 * TCP Process Write
 */
fbt:ip:tcp_send_data:entry
{
	self->conn_p = (conn_t *)args[0]->tcp_connp;
}

fbt:ip:tcp_send_data:entry
/tok[(int)self->conn_p]/
{
        self->size = msgdsize(args[2]) + 14;	/* should check trailers */
	self->uid = tuid[(int)self->conn_p];
	self->laddr = tladdr[(int)self->conn_p];
	self->faddr = tfaddr[(int)self->conn_p];
	self->lport = tlport[(int)self->conn_p];
	self->fport = tfport[(int)self->conn_p];
	OPT_proj ? self->proj = tproj[(int)self->conn_p] : 1;
	self->zoneid = self->conn_p->conn_zoneid;
        self->ok = 2;

	/* follow inetd -> in.* transitions */
	self->name = pid && (tname[(int)self->conn_p] == "inetd") ?
	    execname : tname[(int)self->conn_p];
	self->pid = pid && (tname[(int)self->conn_p] == "inetd") ?
	    pid : tpid[(int)self->conn_p];
	tname[(int)self->conn_p] = self->name;
	tpid[(int)self->conn_p] = self->pid;
}

/*
 * TCP Process Read
 */
fbt:ip:tcp_rput_data:entry
{
	self->conn_p = (conn_t *)arg0;
        self->size = msgdsize(args[1]) + 14;	/* should check trailers */
}

fbt:ip:tcp_rput_data:entry
/tok[(int)self->conn_p]/
{
	self->uid = tuid[(int)self->conn_p];
	self->laddr = tladdr[(int)self->conn_p];
	self->faddr = tfaddr[(int)self->conn_p];
	self->lport = tlport[(int)self->conn_p];
	self->fport = tfport[(int)self->conn_p];
	OPT_proj ? self->proj = tproj[(int)self->conn_p] : 1;
	self->zoneid = self->conn_p->conn_zoneid;
	self->ok = 2;

	/* follow inetd -> in.* transitions */
	self->name = pid && (tname[(int)self->conn_p] == "inetd") ?
	    execname : tname[(int)self->conn_p];
	self->pid = pid && (tname[(int)self->conn_p] == "inetd") ?
	    pid : tpid[(int)self->conn_p];
	tname[(int)self->conn_p] = self->name;
	tpid[(int)self->conn_p] = self->pid;
}

/*
 * TCP Complete printing outbound handshake
 */
fbt:ip:tcp_connect:return
/self->connp/
{
	self->name = tname[(int)self->connp];
	self->pid = tpid[(int)self->connp];
	self->uid = tuid[(int)self->connp];
	self->zoneid = self->connp->conn_zoneid;
	OPT_proj ? self->proj = tproj[(int)self->connp] : 1;
	self->size = 54;	/* should check trailers */

	/* this packet occured before connp was fully established */
	OPT_def ? @out[self->uid, self->pid, self->laddr, self->lport,
	    self->faddr, self->fport, self->name] = sum(self->size) : 1;
	OPT_zone ? @out[self->zoneid, self->pid, self->laddr, self->lport,
	    self->faddr, self->fport, self->name] = sum(self->size) : 1;
	OPT_proj ? @out[self->proj, self->pid, self->laddr, self->lport,
	    self->faddr, self->fport, self->name] = sum(self->size) : 1;
}

/*
 * TCP Complete printing inbound handshake
 */
fbt:sockfs:sotpi_accept:return
/self->connp/
{
	self->name = tname[(int)self->connp];
	self->pid = tpid[(int)self->connp];
	self->uid = tuid[(int)self->connp];
	self->zoneid = self->connp->conn_zoneid;
	OPT_proj ? self->proj = tproj[(int)self->connp] : 1;
	self->size = 54 * 3;	/* should check trailers */

	/* these packets occured before connp was fully established */
	OPT_def ? @out[self->uid, self->pid, self->laddr, self->lport,
	    self->faddr, self->fport, self->name] = sum(self->size) : 1;
	OPT_zone ? @out[self->zoneid, self->pid, self->laddr, self->lport,
	    self->faddr, self->fport, self->name] = sum(self->size) : 1;
	OPT_proj ? @out[self->proj, self->pid, self->laddr, self->lport,
	    self->faddr, self->fport, self->name] = sum(self->size) : 1;
}

/*
 * TCP Save data
 */
fbt:ip:tcp_send_data:entry,
fbt:ip:tcp_rput_data:entry
/self->ok == 2/
{
	/* save r+w data*/
	OPT_def ? @out[self->uid, self->pid, self->laddr, self->lport,
	    self->faddr, self->fport, self->name] = sum(self->size) : 1;
	OPT_zone ? @out[self->zoneid, self->pid, self->laddr, self->lport,
	    self->faddr, self->fport, self->name] = sum(self->size) : 1;
	OPT_proj ? @out[self->proj, self->pid, self->laddr, self->lport,
	    self->faddr, self->fport, self->name] = sum(self->size) : 1;
}

/*
 * TCP Clear connect variables
 */
fbt:sockfs:sotpi_accept:return,
fbt:ip:tcp_connect:return
/self->connp/
{
	self->faddr = 0;
	self->laddr = 0;
	self->fport = 0;
	self->lport = 0;
	self->connp = 0;
	self->name = 0;
	self->pid = 0;
	self->uid = 0;
}

/*
 * TCP Clear r/w variables
 */
fbt:ip:tcp_send_data:entry,
fbt:ip:tcp_rput_data:entry
{
	self->ok = 0;
	self->uid = 0;
	self->pid = 0;
	self->size = 0;
	self->name = 0;
	self->lport = 0;
	self->fport = 0;
	self->laddr = 0;
	self->faddr = 0;
	self->conn_p = 0;
	self->zoneid = 0;
	self->proj = 0;
}

/*
 * TCP Systemwide Stats
 */
mib:::tcpOutDataBytes       { TCP_out += args[0]; }
mib:::tcpRetransBytes       { TCP_out += args[0]; }
mib:::tcpInDataInorderBytes { TCP_in  += args[0]; }
mib:::tcpInDataDupBytes     { TCP_in  += args[0]; }
mib:::tcpInDataUnorderBytes { TCP_in  += args[0]; }

/*
 * Timer
 */
profile:::tick-1sec
{
        secs--;
}

/*
 * Print Report
 */
profile:::tick-1sec
/secs == 0/
{
        /* fetch 1 min load average */
        this->load1a  = `hp_avenrun[0] / 65536;
        this->load1b  = ((`hp_avenrun[0] % 65536) * 100) / 65536;

	/* convert TCP counters to Kb */
	TCP_out /= 1024;
	TCP_in  /= 1024;

	/* print status */
	OPT_clear ? printf("%s", CLEAR) : 1;
        printf("%Y,  load: %d.%02d,  TCPin: %6d Kb,  TCPout: %6d Kb\n\n",
            walltimestamp, this->load1a, this->load1b, TCP_in, TCP_out);

	/* print headers */
	OPT_def  ? printf(" UID ") : 1;
	OPT_proj ? printf("PROJ ") : 1;
	OPT_zone ? printf("ZONE ") : 1;
        printf("%6s %-15s %5s %-15s %5s %9s %s\n",
	    "PID", "LADDR", "LPORT", "RADDR", "RPORT", "SIZE", "NAME");

	/* print data */
        printa("%4d %6d %-15s %5d %-15s %5d %@9d %s\n", @out);
	printf("\n");

	/* clear data */
        trunc(@out);
	TCP_in = 0;
	TCP_out = 0;
        secs = INTERVAL;
        counts--;
}

/*
 * End of program
 */
profile:::tick-1sec
/counts == 0/
{
        exit(0);
}

/*
 * Cleanup for Ctrl-C
 */
dtrace:::END
{
        trunc(@out);
}
')
##############################################################
#!/usr/sbin/dtrace -Cs
/*
 * udpsnoop.d - snoop UDP network I/O by process.
 *              Written using DTrace (Solaris 10 3/05)
 *
 * This analyses UCP network I/O and prints the responsible PID and UID,
 * plus standard details such as IP address and port. This tracks UDP
 * read/writes by payload; this is the same as by packet (although ~42 fewer
 * bytes), unless large datagrams are sent and then fragmented by IP - in
 * which case it becomes obvious that we are printing by payload (sizes > MTU).
 *
 * This program can help identify which processes is causing UDP traffic.
 *
 * 04-Feb-2007, ver 0.56        (check for newer versions)
 *
 * USAGE:       udpsnoop.d
 *
 * FIELDS:
 *              UID             user ID
 *              PID             process ID
 *              CMD             command
 *              LADDR           local IP address
 *              RADDR           remote IP address
 *              LPORT           local port number
 *              RPORT           remote port number
 *              DR              direction
 *              SIZE            payload size, bytes
 *
 * SEE ALSO: snoop -rS, tcpsnoop
 *
 * ATTENTION: This script is currently fragile as it uses the "fbt" DTrace
 * provider, which is an unstable interface. This script is likely to fail
 * on future Solaris versions, including minor updates. This fbt based
 * script was released to provide temporary observability until a stable
 * network provider has been released and this script can be rewritten.
 * See the OpenSolaris dtrace-discuss mailing list for more information.
 *
 * COPYRIGHT: Copyright (c) 2005 Brendan Gregg.
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License
 *  as published by the Free Software Foundation; either version 2
 *  of the License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software Foundation,
 *  Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 *  (http://www.gnu.org/copyleft/gpl.html)
 *
 * Author: Brendan Gregg  [Sydney, Australia]
 *
 * Known Bugs:
 * - destination address is sometimes equal to source address when it
 *   shouldn't. This has been observed with RPC traffic.
 * - outbound traceroute UDP packets are not detected (nor are they by
 *   mib:::udpOutDatagrams).
 * - I'd rather this was packet based than payload based.
 *
 * ToDo: IPv6
 *
 * 14-Jul-2005  Brendan Gregg   Created this.
 * 04-Feb-2007	   "	  "	Updates for newer Solaris.
 */

#pragma D option quiet

#include <inet/common.h>
#include <sys/byteorder.h>

/*
 * Print Header
 */
dtrace:::BEGIN
{
	/* print main headers */
	printf("%5s %6s %-15s %5s %2s %-15s %5s %5s %s\n",
	    "UID", "PID", "LADDR", "LPORT", "DR", "RADDR", "RPORT",
	    "SIZE", "CMD");
}

/*
 * UDP Process Write
 */

/*
 * UDP Track this thread as interesting (mib is our checkpoint)
 */
mib:::udp*OutDatagrams
{
	self->udpOutDatagrams = 1;
}

/*
 * UDP Save IP header info if tracked
 */
fbt::ip_output:entry
/self->udpOutDatagrams/
{
	self->wipha = (ipha_t *)args[1]->b_rptr;
        this->ipha_hlen = (self->wipha->ipha_version_and_hdr_length & 15) * 4;
	self->wsize = msgdsize(args[1]) - this->ipha_hlen - 8;
}

/*
 * UDP Fetch data and print output line
 */
fbt::ip_output:return
/self->udpOutDatagrams/
{

	/* fetch ports */
        this->ipha_hlen = (self->wipha->ipha_version_and_hdr_length & 15) * 4;
        this->udpha = (udpha_t *)(((uchar_t *)self->wipha) + this->ipha_hlen);
#if defined(_BIG_ENDIAN)
	this->sport = this->udpha->uha_src_port;
	this->dport = this->udpha->uha_dst_port;
#else
	this->sport = BSWAP_16(this->udpha->uha_src_port);
	this->dport = BSWAP_16(this->udpha->uha_dst_port);
#endif

	/* fetch IPv4 addresses */
	this->s0 = (self->wipha->ipha_src & 0x000000ff);
	this->s1 = (self->wipha->ipha_src & 0x0000ff00) >> 8;
	this->s2 = (self->wipha->ipha_src & 0x00ff0000) >> 16;
	this->s3 = (self->wipha->ipha_src & 0xff000000) >> 24;
	this->d0 = (self->wipha->ipha_dst & 0x000000ff);
	this->d1 = (self->wipha->ipha_dst & 0x0000ff00) >> 8;
	this->d2 = (self->wipha->ipha_dst & 0x00ff0000) >> 16;
	this->d3 = (self->wipha->ipha_dst & 0xff000000) >> 24;

	/* convert type for use with lltostr() */
	this->s0 = this->s0 < 0 ? 256 + this->s0 : this->s0;
	this->s1 = this->s1 < 0 ? 256 + this->s1 : this->s1;
	this->s2 = this->s2 < 0 ? 256 + this->s2 : this->s2;
	this->s3 = this->s3 < 0 ? 256 + this->s3 : this->s3;
	this->d0 = this->d0 < 0 ? 256 + this->d0 : this->d0;
	this->d1 = this->d1 < 0 ? 256 + this->d1 : this->d1;
	this->d2 = this->d2 < 0 ? 256 + this->d2 : this->d2;
	this->d3 = this->d3 < 0 ? 256 + this->d3 : this->d3;

	/* stringify addresses */
	self->saddr = strjoin(lltostr(this->s0), ".");
	self->saddr = strjoin(self->saddr, strjoin(lltostr(this->s1), "."));
	self->saddr = strjoin(self->saddr, strjoin(lltostr(this->s2), "."));
	self->saddr = strjoin(self->saddr, lltostr(this->s3));
	self->daddr = strjoin(lltostr(this->d0), ".");
	self->daddr = strjoin(self->daddr, strjoin(lltostr(this->d1), "."));
	self->daddr = strjoin(self->daddr, strjoin(lltostr(this->d2), "."));
	self->daddr = strjoin(self->daddr, lltostr(this->d3));

	/* print output line */
	printf("%5d %6d %-15s %5d -> %-15s %5d %5d %s\n", uid, pid,
	    self->saddr, this->sport, self->daddr, this->dport,
	    self->wsize, execname);

	/* clear variables */
	self->wipha = 0;
	self->wsize = 0;
	self->saddr = 0;
	self->daddr = 0;
	self->udpOutDatagrams = 0;
}

/*
 * UDP Process Read
 */

/*
 * The following stores details of the UDP connection. In the
 * future this will be replaced with a struct, when support for
 * zeroing entries in an array of structs is added to DTrace.
 */
int queue[int];
int sport[int];
int dport[int];
string saddr[int];
string daddr[int];

/*
 * The following is some stateful code that is intended to identify
 * getq_noneab()s that began with a udp_rput which also triggered
 * a mib:::udpInDatagrams. This combination tracks an inbound UDP
 * packet from kernel to userland. The following code blocks are
 * listed in chronological order.
 */

/*
 * UDP Track all rputs
 */
fbt::udp_rput:entry
{
	self->qp = args[0];
	self->ripha = (ipha_t *)args[1]->b_rptr;
}

/*
 * UDP Mark this rput as interesting (mib is our checkpoint)
 */
mib:::udp*InDatagrams
/self->qp/
{
	self->udpInDatagrams = 1;

	/* fetch ports */
	this->ipha_hlen = (self->ripha->ipha_version_and_hdr_length & 15) * 4;
	this->udpha = (udpha_t *)(((uchar_t *)self->ripha) + this->ipha_hlen);
#if defined(_BIG_ENDIAN)
	self->sport = this->udpha->uha_src_port;
	self->dport = this->udpha->uha_dst_port;
#else
	self->sport = BSWAP_16(this->udpha->uha_src_port);
	self->dport = BSWAP_16(this->udpha->uha_dst_port);
#endif

	/* fetch IPv4 addresses */
	this->s0 = (self->ripha->ipha_src & 0x000000ff);
	this->s1 = (self->ripha->ipha_src & 0x0000ff00) >> 8;
	this->s2 = (self->ripha->ipha_src & 0x00ff0000) >> 16;
	this->s3 = (self->ripha->ipha_src & 0xff000000) >> 24;
	this->d0 = (self->ripha->ipha_dst & 0x000000ff);
	this->d1 = (self->ripha->ipha_dst & 0x0000ff00) >> 8;
	this->d2 = (self->ripha->ipha_dst & 0x00ff0000) >> 16;
	this->d3 = (self->ripha->ipha_dst & 0xff000000) >> 24;

        /* convert type for use with lltostr() */
        this->s0 = this->s0 < 0 ? 256 + this->s0 : this->s0;
        this->s1 = this->s1 < 0 ? 256 + this->s1 : this->s1;
        this->s2 = this->s2 < 0 ? 256 + this->s2 : this->s2;
        this->s3 = this->s3 < 0 ? 256 + this->s3 : this->s3;
        this->d0 = this->d0 < 0 ? 256 + this->d0 : this->d0;
        this->d1 = this->d1 < 0 ? 256 + this->d1 : this->d1;
        this->d2 = this->d2 < 0 ? 256 + this->d2 : this->d2;
        this->d3 = this->d3 < 0 ? 256 + this->d3 : this->d3;

        /* stringify addresses */
        self->saddr = strjoin(lltostr(this->s0), ".");
        self->saddr = strjoin(self->saddr, strjoin(lltostr(this->s1), "."));
        self->saddr = strjoin(self->saddr, strjoin(lltostr(this->s2), "."));
        self->saddr = strjoin(self->saddr, lltostr(this->s3));
        self->daddr = strjoin(lltostr(this->d0), ".");
        self->daddr = strjoin(self->daddr, strjoin(lltostr(this->d1), "."));
        self->daddr = strjoin(self->daddr, strjoin(lltostr(this->d2), "."));
        self->daddr = strjoin(self->daddr, lltostr(this->d3));
}

/*
 * UDP Save bridge data by queue (kernel -> userland)
 */
fbt:genunix:putq:entry
/self->udpInDatagrams/
{
	/* save IP data */
	queue[arg0] = 1;
	sport[arg0] = self->sport;
	dport[arg0] = self->dport;
	saddr[arg0] = self->saddr;
	daddr[arg0] = self->daddr;
}

/*
 * UDP Done with rput
 */
fbt::udp_rput:return
/self->qp/
{
	/* clear variables */
	self->qp = 0;
	self->ripha = 0;
	self->sport = 0;
	self->dport = 0;
	self->saddr = 0;
	self->daddr = 0;
	self->udpInDatagrams = 0;
}

/*
 * UDP Track this getq_noenab, if queue was marked
 */
fbt:genunix:getq_noenab:entry
/queue[arg0]/
{
	/* track userland queue read */
	self->gq = args[0];
}

/*
 * UDP Retrieve data from queue marked by putq
 */
fbt:genunix:getq_noenab:return
/self->gq/
{
	/* fetch read size */
	this->size = msgdsize((struct msgb *)arg1);
	this->size = (int)this->size > 0 ? this->size : 0;

	/* print output line */
	printf("%5d %6d %-15s %5d <- %-15s %5d %5d %s\n", uid, pid,
	    daddr[(int)self->gq], dport[(int)self->gq], saddr[(int)self->gq],
	    sport[(int)self->gq], this->size, execname);
}

/*
 * UDP Clear bridge data, if queue empty
 */
fbt:genunix:getq_noenab:return
/self->gq && (self->gq->q_count == 0)/
{
	/* clear IP data variables */
	queue[(int)self->gq] = 0;
	saddr[(int)self->gq] = 0;
	daddr[(int)self->gq] = 0;
	sport[(int)self->gq] = 0;
	dport[(int)self->gq] = 0;
}

/*
 * UDP Done with getq_noenab
 */
fbt:genunix:getq_noenab:return
/self->gq/
{
	self->gq = 0;
}
##############################################################
#!/usr/bin/ksh
#
# connections - print inbound TCP connections by process.
#               Written in DTrace (Solaris 10 3/05).
#
# This displays the PID and command name of the processes accepting
# connections, along with the source IP address and destination port number.
#
# 04-Dec-2005, ver 0.85			(check for newer versions)
#
# USAGE:	connections [-htvZ]
#
#		-t		# print timestamps, us
#		-v		# print timestamps, string
#		-Z		# print zonename
#	eg,
#		connections -v	# snoop connections with times
#
# FIELDS:
#		UID		user ID of the server
#		PID		process ID for the server
#		CMD		server command name
#		TIME		timestamp, us
#		TIMESTR		timestamp, string
#		PORT		server port
#		IP_SOURCE	source IP of the client, written in IPv4 style
#		ZONE		zonename
#
# SEE ALSO:	snoop 'tcp[13:1] = 0x02'	# snoop new connections
#
# COPYRIGHT: Copyright (c) 2005 Brendan Gregg.
#
# CDDL HEADER START
#
#  The contents of this file are subject to the terms of the
#  Common Development and Distribution License, Version 1.0 only
#  (the "License").  You may not use this file except in compliance
#  with the License.
#
#  You can obtain a copy of the license at Docs/cddl1.txt
#  or http://www.opensolaris.org/os/licensing.
#  See the License for the specific language governing permissions
#  and limitations under the License.
#
# CDDL HEADER END
#
# TODO: IPv6
#
# 10-Apr-2004	Brendan Gregg	Created this.
# 23-May-2004	   "      "  	Fixed issues on SPARC.
# 08-May-2005	   "      "  	Updated for newer Solaris 10.
# 17-Jun-2005	   "      "	Rewrote, changed probes, wrapped in sh.
# 04-Dec-2005	   "	  "	Changed tcp_accept_finish -> sotpi_accept
#


##############################
# --- Process Arguments ---
#

### Default variables
opt_time=0; opt_timestr=0; opt_zone=0

### Process options
while getopts htvZ name
do
	case $name in
	t)      opt_time=1 ;;
	v)      opt_timestr=1 ;;
	Z)      opt_zone=1 ;;
	h|?)    cat <<-END >&2
		USAGE: connections [-htvZ]
			   -t              # print timestamps, us
			   -v              # print timestamps, string
			   -Z              # print zonename
		  eg,
		       connections -v      # snoop connections with times
		END
		exit 1
	esac
done


#################################
# --- Main Program, DTrace ---
#
/usr/sbin/dtrace -C -s <( print -r '
#include <sys/file.h>
#include <sys/types.h>
#include <sys/byteorder.h>
#include <sys/socket.h>
#include <sys/socketvar.h>

 #pragma D option quiet
 #pragma D option switchrate=10hz

 inline int OPT_time    = '$opt_time';
 inline int OPT_timestr = '$opt_timestr';
 inline int OPT_zone    = '$opt_zone';

 /*
  * Print header
  */
 dtrace:::BEGIN
 {
        /* print optional headers */
        OPT_time    ? printf("%-14s ", "TIME") : 1;
        OPT_timestr ? printf("%-20s ", "TIMESTR") : 1;
	OPT_zone    ? printf("%-10s ", "ZONE") : 1;

	/* print header */
	printf("%5s %5s %-12s %4s %5s %s\n",
	    "UID", "PID", "CMD", "TYPE", "PORT", "IP_SOURCE");
 }

 /*
  * TCP Process inbound connections
  */
 fbt:sockfs:sotpi_accept:entry
 /(arg1 & FREAD) && (arg1 & FWRITE) && (args[0]->so_state & SS_TCP_FAST_ACCEPT)/
 {
	self->sop = args[0];
 }

 fbt:sockfs:sotpi_create:return
 /self->sop/
 {
	self->nsop = (struct sonode *)arg1;
 }


 /*
  * Probe TCP connections
  */
 fbt:sockfs:sotpi_accept:return
 /self->nsop/
 {
	/* fetch connection details */
	this->tcpp = (tcp_t *)self->nsop->so_priv;
	this->connp = (conn_t *)this->tcpp->tcp_connp;

#if defined(_BIG_ENDIAN)
	this->port0 = this->connp->u_port.tcpu_ports.tcpu_lport;
#else
	this->port0 = BSWAP_16(this->connp->u_port.tcpu_ports.tcpu_lport);
#endif
	this->rem12 =
	    (uint8_t)this->connp->connua_v6addr.connua_faddr._S6_un._S6_u8[12];
	this->rem13 =
	    (uint8_t)this->connp->connua_v6addr.connua_faddr._S6_un._S6_u8[13];
	this->rem14 =
	    (uint8_t)this->connp->connua_v6addr.connua_faddr._S6_un._S6_u8[14];
	this->rem15 =
	    (uint8_t)this->connp->connua_v6addr.connua_faddr._S6_un._S6_u8[15];

        /* print optional fields */
        OPT_time    ? printf("%-14d ", timestamp/1000) : 1;
        OPT_timestr ? printf("%-20Y ", walltimestamp) : 1;
	OPT_zone    ? printf("%-10s ", zonename) : 1;

	/* print output line */
	printf("%5d %5d %-12s %4s %5d %d.%d.%d.%d\n",
	    uid, pid, execname, "tcp", this->port0,
	    this->rem12, this->rem13, this->rem14, this->rem15);
 }

 fbt:sockfs:sotpi_accept:return
 {
	self->nsop = 0;
	self->sop = 0;
 }
')

##############################################################
#!/usr/bin/perl
#
# prustat - Process utilisation stats: %CPU, %Mem, %Disk, %Net. Solaris 10.
#	Needs to run as root. This is a demonstration release - check for
#	newer optimised versions. Uses Kstat, DTrace and procfs.
#
# 12-Mar-2005, ver 0.50  (demonstration release, http://www.brendangregg.com)
#
#
# USAGE:
#       prustat [-cehinuwxz] [-p PID] [-s sort] [-t top] [interval] [count]
#
#      prustat               # %Utilisation
#      prustat -i            # + I/O stats
#      prustat -u            # + USR/SYS times
#      prustat -x            # + Context Switchs
#      prustat -c            # Clear screen
#      prustat -w            # Wide output
#      prustat -z            # Skip zero lines
#      prustat -e            # Extra precision
#      prustat -p PID        # this PID only
#      prustat -s sort       # sort on pid|cpu|mem|disk|net|utime|vctx|...
#      prustat -t lines      # print top number of lines only
#  eg,
#      prustat 2                # 2 second samples (first is historical)
#      prustat 10 5             # 5 x 10 second samples
#      prustat -t 8 10 5        # 5 x 10 second samples, top 8 lines only
#      prustat -ct 20 5         # 20 lines with screen refresh each 5 seconds
#      prustat -iuxct 5 10      # multi output, all reports every 10 seconds
#      prustat -ct 22 -s cpu 5	# 22 lines, sort by cpu, every 5 secs
#      prustat -ct 22 -s mem 5	# 22 lines, sort by mem, every 5 secs
#      prustat -ct 22 -s net 5	# 22 lines, sort by network, every 5 secs
#      prustat -ct 22 -s disk 5	# 22 lines, sort by disk, every 5 secs
#
# FIELDS:
#		PID	Process ID
#		CPU	Percent CPU
#		Mem	Percent RAM
#		Disk	Percent Disk
#		Net	Percent Network
#		MAJF	Major Page Faults (disk I/O)
#		INBLK	In Blocks (disk I/O reads)
#		OUBLK	Out Blocks (disk I/O writes)
#		CHAR-kb	Character I/O Kbytes
#		COMM	Command name
#		USR	User Time
#		SYS 	System Time
#		WAIT	Wait for CPU Time
#		VCTX	Voluntary Context Switches (I/O bound)
#		ICTX	Involuntary Context Switches (CPU bound)
#		SYSC	System calls
#
# WARNING: This program will run DTrace to gather Disk and Network data.
#	This has not been fully tested on different environments to study the
# 	impact of these extra measurements. For now this is a demonstration
#	release - best to run in development for short periods. Check for
#	newer versions and updates to this message.
#
# NOTE: There is no historical values for Disk or Network utilisation percent,
#	the first sample for these will always show zero.
#
# REFERENCES: /usr/include/sys/procfs.h
#
# SEE ALSO: iosnoop, psio, prusage		# process Disk I/O
#           socketsnoop.d			# process TCP
#	    prstat -m				# USR/SYS times, ...
#
# COPYRIGHT: Copyright (c) 2005 Brendan Gregg.
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#  (http://www.gnu.org/copyleft/gpl.html)
#
# Author: Brendan Gregg  [Sydney, Australia]
#
# 12-Mar-2005	Brendan Gregg	Created this.

use Getopt::Std;
use Sun::Solaris::Kstat;
my $Kstat = Sun::Solaris::Kstat->new();


#
# --- Default Variables ---
#
$INTERVAL = 1;		# seconds to sample
$MAX = 1;		# max count of samples
$NEW = 0;		# skip summary output (new data only)
$WIDE = 0;		# print wide output (don't truncate)
$SCHED = 0;		# print PID 0
$TOP = 0;		# print top many only
$CLEAR = 0;		# clear screen before outputs
$ZERO = 0;		# if 1, skip zero entries (all 0.00)
$STYLE_UTIL = 1;	# default output style, utilisation
$STYLE_IO = 0;		# output style, I/O
$STYLE_CTX = 0;		# output style, Context Switches
$STYLE_TIME = 0;	# output style, Times
$STYLE_EXTRA = 0;	# output style, Extra precision
$MULTI = 0;		# multi report, multiple styles
$TARGET_PID = -1;	# target PID, -1 means all
$TIME_BEGIN = 1;	# start of interval, ns
$TIME_END = 1;		# end of interval, ns
$count = 1;		# current iteration
$NIC_DEF = 100_000_000; # default NIC speed (100 Mbps)

### Network card instance names
@Network = qw(dmfe bge be ce eri ge hme le ppp qfe rtls sppp iprb);
$Network{$_} = 1 foreach (@Network);


#
# --- Command Line Arguments ---
#
&Usage() if $ARGV[0] eq "--help";
getopts('cehinuwxzp:s:t:') || &Usage();
&Usage() if $opt_h;
$NEW = 1 if $opt_n;
$WIDE = 1 if $opt_w;
$CLEAR = 1 if $opt_c;
$ZERO = 1 if $opt_z;
$STYLE_IO = 1 if $opt_i;
$STYLE_CTX = 1 if $opt_x;
$STYLE_TIME = 1 if $opt_u;
$STYLE_EXTRA = 1 if $opt_e;
$STYLE_IO = 1 if $opt_i;
$STYLE_UTIL = 0 if $opt_i || $opt_x || $opt_u || $opt_e;
$TOP = $opt_t if defined $opt_t;
$SORT = $opt_s if defined $opt_s;
$TARGET_PID = $opt_p if defined $opt_p;
$MAX = 2**32 if @ARGV == 1;
$INTERVAL = shift(@ARGV) || $INTERVAL;
$MAX = shift(@ARGV) || $MAX;
$CLEARSTR = `clear` if $CLEAR;
$MULTI = 1 if ($STYLE_IO + $STYLE_CTX + $STYLE_TIME) > 1;


#
# --- Determine Network Capacity ---
#
my ($error,$time,$module,$instance,$name);
my ($bytes,$rbytes,$wbytes);
my (%Modules,%Instances,%Names);
$NIC_SPEED = 0;		# sum of Mbps across all NICs

### Loop over all NICs
foreach $module (keys(%$Kstat)) {
	next unless $Network{$module};
	$Modules = $Kstat->{$module};
	foreach $instance (keys(%$Modules)) {
		$Instances = $Modules->{$instance};
		foreach $name (keys(%$Instances)) {
			$Names = $Instances->{$name};
			if (defined $$Names{ifspeed}) {
				$NIC_SPEED += $$Names{ifspeed};
			} else {
				$NIC_SPEED += $NIC_SPEED;
			}
		}
	}
}
$NIC_SPEED = $NIC_DEF if $NIC_SPEED == 0;


#
# --- Open DTrace ---
#
@Dscript = <DATA>;
$dscript = join('',@Dscript);
open(DTRACE,"$dscript 2>/dev/null |") || die("ERROR1: Can't open dtrace: $!\n");

### Cleanup on signals
$SIG{INT} = \&Cleanup;
$SIG{QUIT} = \&Cleanup;
$SIG{TERM} = \&Cleanup;
$SIG{PIPE} = \&Cleanup;


#
# --- Main ---
#
for (;$count <= $MAX; $count++) {

	### Get CPU and Mem data
	&GetProcStat();

	next if $NEW && $count == 1;

	### Preprocess PID
	&ProcessPID();

	### Print data
	print $CLEARSTR if $CLEAR;
	&PrintUtil($SORT) if $STYLE_UTIL;
	&PrintExtra($SORT) if $STYLE_EXTRA;
	&PrintIO($SORT) if $STYLE_IO;
	&PrintCtx($SORT) if $STYLE_CTX;
	&PrintTime($SORT) if $STYLE_TIME;

	### Cleanup memory
	undef %Comm;
	undef %PID;
	$TIME_BEGIN = $TIME_END;

	### Get Disk and Net data
	for ($pause = 0; $pause < $INTERVAL; $pause++) {
		&GetDTraceStat();
	}
}

close(DTRACE);


#
# --- Subroutines ---
#

# GetProcStat - Gets /proc usage statistics and saves them in %PID.
#	This can be run multiple times, the first time %PID will be
#	populated with the summary since boot values.
#	This reads /proc/*/usage and /proc/*/prstat.
#
sub GetProcStat {
   my $pid;
   chdir "/proc";

   ### Main PID Loop
   foreach $pid (sort {$a<=>$b} <*>) {
	next if $pid == $$;
	next if $pid == 0 && $SCHED == 0;
	next if $TARGET_PID > -1 && $pid != $TARGET_PID;

	### Read usage stats
	open(USAGE,"/proc/$pid/usage") || next;
	read(USAGE,$usage,256);
	close USAGE;

	### Unpack usage values
	($pr_lwpid, $pr_count, $pr_tstamp, $pr_create, $pr_term,
	 $pr_rtime, $pr_utime, $pr_stime, $pr_ttime, $pr_tftime,
	 $pr_dftime, $pr_kftime, $pr_ltime, $pr_slptime, $pr_wtime,
	 $pr_stoptime, $filltime, $pr_minf, $pr_majf, $pr_nswap,
	 $pr_inblk, $pr_oublk, $pr_msnd, $pr_mrcv, $pr_sigs,
	 $pr_vctx, $pr_ictx, $pr_sysc, $pr_ioch, $filler) =
	 unpack("iia8a8a8a8a8a8a8a8a8a8a8a8a8a8a48LLLLLLLLLLLLa40",$usage);

	### Process usage values
	$New{$pid}{utime} = timestruct2int($pr_utime);
	$New{$pid}{stime} = timestruct2int($pr_stime);
	$New{$pid}{ttime} = timestruct2int($pr_ttime);
	$New{$pid}{ltime} = timestruct2int($pr_ltime);
	$New{$pid}{wtime} = timestruct2int($pr_wtime);
	$New{$pid}{slptime} = timestruct2int($pr_slptime);
	$New{$pid}{minf}  = $pr_minf;
	$New{$pid}{majf}  = $pr_majf;
	$New{$pid}{nswap} = $pr_nswap;
	$New{$pid}{inblk} = $pr_inblk;
	$New{$pid}{oublk} = $pr_oublk;
	$New{$pid}{vctx}  = $pr_vctx;
	$New{$pid}{ictx}  = $pr_ictx;
	$New{$pid}{sysc}  = $pr_sysc;
	$New{$pid}{ioch}  = $pr_ioch;
	# and a couple of my own,
	$New{$pid}{blks}  = $pr_inblk + $pr_oublk;
	$New{$pid}{ctxs}  = $pr_vctx + $pr_ictx;


	### Read psinfo stats
	open(PSINFO,"/proc/$pid/psinfo") || next;
	read(PSINFO,$psinfo,256);
	close PSINFO;

	### Unpack psinfo values
	($pr_flag, $pr_nlwp, $pr_pid, $pr_ppid, $pr_pgid, $pr_sid,
	 $pr_uid, $pr_euid, $pr_gid, $pr_egid, $pr_addr, $pr_size,
	 $pr_rssize, $pr_pad1, $pr_ttydev, $pr_pctcpu, $pr_pctmem,
	 $pr_start, $pr_time, $pr_ctime, $pr_fname, $pr_psargs,
	 $pr_wstat, $pr_argc, $pr_argv, $pr_envp, $pr_dmodel,
	 $pr_taskid, $pr_projid, $pr_nzomb, $pr_poolid, $pr_zoneid, $filler) =
	 unpack("iiiiiiiiiiIiiiiSSa8a8a8Z16Z80iiIIaa3iiiiii",$psinfo);

	### Process psinfo values
	$PID{$pid}{pctcpu} = $pr_pctcpu / 0x8000;
	$PID{$pid}{pctmem} = $pr_pctmem / 0x8000;
	$PID{$pid}{uid} = $pr_uid;
	$New{$pid}{size}   = $pr_size;
	$New{$pid}{rssize} = $pr_rssize;

	### Save command name
	$Comm{$pid} = $pr_fname;
   }

   ### Turn incrementals into values
   foreach $pid (keys %New) {
	# save PID values,
	foreach $key (keys %{$New{$pid}}) {
		$PID{$pid}{$key} = $New{$pid}{$key} - $Old{$pid}{$key};
	}
   }
   undef %Old;

   ### Remember old value
   foreach $pid (keys %New) {
	# save old values,
	foreach $key (keys %{$New{$pid}}) {
		$Old{$pid}{$key} = $New{$pid}{$key};
	}
   }
}


# GetDTraceStat - read detals from a DTrace connection until a heartbeat
#	is read (happens every second).
#
sub GetDTraceStat {
	my ($line,$cmd,$rest,$uid,$pid,$size,$name,$delta);

	while ($line = <DTRACE>) {
		chomp($line);
		($cmd,$rest) = split(' ',$line,2);

		### Start
		$TIME_BEGIN = $rest if $cmd eq "B";

		### Heartbeat
		if ($cmd eq "T") {
			$TIME_END = $rest;
			last;
		}

		### Network traffic
		if ($cmd eq "N") {
			($uid,$pid,$size,$name) = split(' ',$rest);
			next if $TARGET_PID > -1 && $pid != $TARGET_PID;
			$PID{$pid}{netrw} += $size;
			unless (defined $Comm{$pid}) {
				$Comm{$pid} = $name;
				$PID{$pid}{uid} = $uid;
			}
		}

		### Disk traffic
		if ($cmd eq "D") {
			($uid,$pid,$delta,$size,$name) = split(' ',$rest);
			next if $TARGET_PID > -1 && $pid != $TARGET_PID;
			$PID{$pid}{dtime} += $delta;
			unless (defined $Comm{$pid}) {
				$Comm{$pid} = $name;
				$PID{$pid}{uid} = $uid;
			}
		}
	}
}

# ProcessPID - pre process %PID before printing.
#	This calculates values such as sumpct for sorting.
#
sub ProcessPID {
	my ($pid,$cpu,$mem,$disk,$net,$sample);
	my ($factorcpu,$factormem,$factordisk,$factornet);

	### Factors for %util conversions
	$sample = $TIME_END - $TIME_BEGIN || 1;
	$factorcpu = 100;
	$factormem = 100;
	$factordisk = 100 / $sample;
	$factornet = 800 / ($NIC_SPEED * ($sample / 1_000_000_000));

	### Process %PID
	foreach $pid (keys(%PID)) {
		$cpu = $PID{$pid}{pctcpu} * $factorcpu;
		$mem = $PID{$pid}{pctmem} * $factormem;
		$disk = $PID{$pid}{dtime} * $factordisk;
		$net = $PID{$pid}{netrw} * $factornet;
		$PID{$pid}{cpu} = $cpu;
		$PID{$pid}{mem} = $mem;
		$PID{$pid}{disk} = $disk;
		$PID{$pid}{net} = $net;
		$PID{$pid}{all} = $cpu + $mem + $disk + $net;
	}
}

# PrintUtil - print a report on utilisation.
#
sub PrintUtil {
	my $sort = shift || "all";
	my $top = $TOP;
	my ($pid,$cpu,$mem,$disk,$net,$all);

	### Print header
	printf("%5s %6s %6s %6s %6s  %s\n","PID",
	 "%CPU","%Mem","%Disk","%Net","COMM");

	### Print report
	foreach $pid (&SortPID("$sort")) {

		# Fetch utilisations
		$cpu = $PID{$pid}{cpu};
		$mem = $PID{$pid}{mem};
		$disk = $PID{$pid}{disk};
		$net = $PID{$pid}{net};
		$all = $PID{$pid}{all};

		# Skip zero lines if needed
		if ($ZERO && ($all < 0.02)) { next; }

		# Print output
		printf("%5s %6.2f %6.2f %6.2f %6.2f  %s\n",$pid,
		 $cpu,$mem,$disk,$net,trunc($Comm{$pid},33));
		last if --$top == 0;
	}
	print "\n" if $MULTI;
}

# PrintExtra - print a report on utilisation, with extra decimal places.
#
sub PrintExtra {
	my $sort = shift || "all";
	my $top = $TOP;
	my ($pid,$cpu,$mem,$disk,$net,$all);

	### Print header
	printf("%5s %8s %8s %8s %8s  %s\n","PID",
	 "%CPU","%Mem","%Disk","%Net","COMM");

	### Print report
	foreach $pid (&SortPID("$sort")) {

		# Fetch utilisations
		$cpu = $PID{$pid}{cpu};
		$mem = $PID{$pid}{mem};
		$disk = $PID{$pid}{disk};
		$net = $PID{$pid}{net};
		$all = $PID{$pid}{all};

		# Skip zero lines if needed
		if ($ZERO && ($all < 0.02)) { next; }

		# Print output
		printf("%5s %8.4f %8.4f %8.4f %8.4f  %s\n",$pid,
		 $cpu,$mem,$disk,$net,trunc($Comm{$pid},33));
		last if --$top == 0;
	}
	print "\n" if $MULTI;
}

# PrintIO - print a report with I/O statistics: minf, majf, inblk, oublk, ioch.
#
sub PrintIO {
	my $sort = shift || "blks";
	my $top = $TOP;
	my ($pid,$cpu,$mem,$disk,$net,$all);

	### Print header
	printf("%5s %6s %6s %6s %6s %8s %8s %9s %s\n","PID",
	 "%CPU","%Mem","%Disk","%Net","INBLK","OUBLK",
	 "CHAR-kb","COMM");

	### Print report
	foreach $pid (&SortPID("$sort")) {

		# Fetch utilisations
		$cpu = $PID{$pid}{cpu};
		$mem = $PID{$pid}{mem};
		$disk = $PID{$pid}{disk};
		$net = $PID{$pid}{net};
		$all = $PID{$pid}{all};

		# Skip zero lines if needed
		if ($ZERO && ($all < 0.02)) { next; }

		# Print output
		printf("%5s %6.2f %6.2f %6.2f %6.2f %8d %8d %9.0f %s\n",
		 $pid,$cpu,$mem,$disk,$net,$PID{$pid}{inblk},
		 $PID{$pid}{oublk},$PID{$pid}{ioch}/1024,
		 trunc($Comm{$pid},33));
		last if --$top == 0;
	}
	print "\n" if $MULTI;
}

# PrintTime - print a report including usr, sys and wait times.
#
sub PrintTime {
	my $sort = shift || "cpu";
	my $top = $TOP;
	my ($pid,$cpu,$mem,$disk,$net,$all);

	### Print header
	printf("%5s %6s %6s %6s %6s %8s %8s %8s %s\n","PID",
	 "%CPU","%Mem","%Disk","%Net","USR","SYS",
	 "WAIT","COMM");

	### Print report
	foreach $pid (&SortPID("$sort")) {

		# Fetch utilisations
		$cpu = $PID{$pid}{cpu};
		$mem = $PID{$pid}{mem};
		$disk = $PID{$pid}{disk};
		$net = $PID{$pid}{net};
		$all = $PID{$pid}{all};

		# Skip zero lines if needed
		if ($ZERO && ($all < 0.02)) { next; }

		# Print output
		printf("%5s %6.2f %6.2f %6.2f %6.2f %8d %8d %8d %s\n",
		 $pid,$cpu,$mem,$disk,$net,$PID{$pid}{utime},
		 $PID{$pid}{stime},$PID{$pid}{wtime},
		 trunc($Comm{$pid},33));
		last if --$top == 0;
	}
	print "\n" if $MULTI;
}

# PrintCtx - print a report on context switches: vctx, ictx and sys calls.
#
sub PrintCtx {
	my $sort = shift || "ctxs";
	my $top = $TOP;
	my ($pid,$cpu,$mem,$disk,$net,$all);

	### Print header
	printf("%5s %6s %6s %6s %6s %8s %8s %9s %s\n","PID",
	 "%CPU","%Mem","%Disk","%Net","VCTX","ICTX",
	 "SYSC","COMM");

	### Print report
	foreach $pid (&SortPID("$sort")) {

		# Fetch utilisations
		$cpu = $PID{$pid}{cpu};
		$mem = $PID{$pid}{mem};
		$disk = $PID{$pid}{disk};
		$net = $PID{$pid}{net};
		$all = $PID{$pid}{all};

		# Skip zero lines if needed
		if ($ZERO && ($all < 0.02)) { next; }

		# Print output
		printf("%5s %6.2f %6.2f %6.2f %6.2f %8d %8d %9d %s\n",
		 $pid,$cpu,$mem,$disk,$net,$PID{$pid}{vctx},
		 $PID{$pid}{ictx},$PID{$pid}{sysc},
		 trunc($Comm{$pid},33));
		last if --$top == 0;
	}
	print "\n" if $MULTI;
}

# SortPID - sorts the PID hash by the key given as arg1, returning a sorted
#	array of PIDs.
#
sub SortPID {
	my $sort = shift;

	### Sort numerically
	if ($sort eq "pid") {
   		return sort {$a <=> $b} (keys %PID);
	} else {
   		return sort {$PID{$b}{$sort} <=> $PID{$a}{$sort}} (keys %PID);
	}
}

# timestruct2int - Convert a timestruct value (64 bits) into an integer
#	of seconds.
#
sub timestruct2int {
	my $timestruct = shift;
	my ($secs,$nsecs) = unpack("LL",$timestruct);
	my $time = $secs + $nsecs * 10**-9;
	return $time;
}

# trunc - Returns a truncated string if required.
#
sub trunc {
	my $string = shift;
	my $length = shift;

	if ($WIDE) {
		return $string;
	} else {
		return substr($string,0,$length);
	}
}

# Cleanup - subroutine for signal management.
#
sub Cleanup {
	close(DTRACE);
	exit(0);
}

# Usage - print usage message and exit.
#
sub Usage {
	print STDERR <<END;
prustat ver 0.50, demo release
USAGE: prustat [-cehinuwxz] [-p PID] [-s sort] [-t top] [interval] [count]

      prustat               # \%Utilisation
      prustat -i            # + I/O stats
      prustat -u            # + USR/SYS times
      prustat -x            # + Context Switchs
      prustat -c            # Clear screen
      prustat -w            # Wide output
      prustat -z            # Skip zero lines
      prustat -e            # Extra precision
      prustat -p PID        # this PID only
      prustat -s sort       # sort on pid|cpu|mem|disk|net|utime|vctx|...
      prustat -t lines      # print top number of lines only
  eg,
      prustat 2                # 2 second samples (first is historical)
      prustat 10 5             # 5 x 10 second samples
      prustat -t 8 10 5        # 5 x 10 second samples, top 8 lines only
      prustat -ct 20 5         # 20 lines with screen refresh each 5 seconds
      prustat -iuxct 5 10      # multi output, all reports every 10 seconds
      prustat -ct 22 -s cpu 5	# 22 lines, sort by cpu, every 5 secs
      prustat -ct 22 -s mem 5	# 22 lines, sort by mem, every 5 secs
      prustat -ct 22 -s net 5	# 22 lines, sort by network, every 5 secs
      prustat -ct 22 -s disk 5	# 22 lines, sort by disk, every 5 secs

END
	exit;
}

#
# --- DTrace ---
#

__DATA__
/usr/sbin/dtrace -n '
/*
** The following is a trimmed version of two seperate DTrace scripts:
**
** socketsnoop.d - snoop TCP network socket traffic by process.
**  This is intended to identify the process responsible
**  for network traffic. Written in DTrace (Solaris 10 build 63).
**
** iosnoop.d - A program to print I/O events as they happen, with useful
**	details such as UID, PID, inode, command, etc.
**	Written in DTrace (Solaris 10 build 63).
**
*/

#pragma D option quiet


/*
** --- TIMESTAMPS ---
*/
dtrace:::BEGIN {
	printf("B %d\n",timestamp);
	/* last is used as a timestamp to the disk request, OR,
	   to the last disk completion. This is needed to avoid
	   over counting disk times due to disk buffers (queues),
	   however remains a minor simplification. */
	last = timestamp;
}
profile:::tick-1sec {
	/* heartbeat */
	printf("T %d\n",timestamp);
}


/*
** --- DISK ----
*/

/*
**  Store entry details
*/
io:::start
{
	this->dev = args[0]->b_edev;
	this->blk = args[0]->b_blkno;
	start_uid[this->dev,this->blk] = curpsinfo->pr_euid;
	start_pid[this->dev,this->blk] = pid;
	start_comm[this->dev,this->blk] = (char *)curpsinfo->pr_fname;
	last = timestamp;
}

/*
**  Process completion
*/
io:::done
{
	/* fetch entry values */
	this->dev = args[0]->b_edev;
	this->blk = args[0]->b_blkno;
	this->delta = timestamp - last;
	this->suid = start_uid[this->dev,this->blk];
	this->spid = start_pid[this->dev,this->blk];
	this->scomm = start_comm[this->dev,this->blk];

	/* memory cleanup */
	start_uid[this->dev,this->blk] = 0;
	start_pid[this->dev,this->blk] = 0;
	start_comm[this->dev,this->blk] = 0;
	last = timestamp;
}

/*
**  Print event details
*/
io:::done
{
        printf("D %d %d %d %d %s\n",
         this->suid,this->spid,this->delta,args[0]->b_bcount,
         this->scomm == 0 ? "." : stringof(this->scomm));
}


/*
** --- NETWORK ----
*/

/*
**  Store Write Values
*/
fbt:ip:tcp_output:entry
{
        self->uid = curpsinfo->pr_euid;
        self->pid = pid;
        self->comm = (char *)curpsinfo->pr_fname;
        self->size = msgdsize(args[1]);
	self->ok = 1;
}

/*
**  Store Read Values
*/
fbt:sockfs:sotpi_recvmsg:entry
{
        self->uid = curpsinfo->pr_euid;
        self->pid = pid;
        self->comm = (char *)curpsinfo->pr_fname;
	/* We track the read request (man uio), */
	self->uiop = (struct uio *) arg2;
	self->residual = self->uiop->uio_resid;
	/* The following ensures the type is AF_INET (sys/socket.h), */
	this->sonode = (struct sonode *)arg0;
	self->ok = (int)this->sonode->so_type == 2 ? 1 : 0;
}
fbt:sockfs:sotpi_recvmsg:return
/arg0 != 0 && self->ok/
{
	/* calculate successful read size */
	self->size = self->residual - self->uiop->uio_resid;
}

/*
**  Print output
*/
fbt:ip:tcp_output:entry, fbt:sockfs:sotpi_recvmsg:return
/self->ok/
{
        printf("N %d %d %d %s\n",self->uid,self->pid,
	 self->size,stringof(self->comm));
	self->ok = 0;
	self->uid = 0;
	self->pid = 0;
	self->comm = 0;
	self->size = 0;
	self->residual = 0;
	self->uiop = 0;
}
'
##############################################################
#!/usr/bin/sh
#
# dtruss - print process system call time details.
#          Written using DTrace (Solaris 10 3/05).
#
# 17-Jun-2005, ver 0.80         (check for newer versions)
#
# USAGE: dtruss [-acdeflhoLs] [-t syscall] { -p PID | -n name | command }
#
#          -p PID          # examine this PID
#          -n name         # examine this process name
#          -t syscall      # examine this syscall only
#          -a              # print all details
#          -c              # print system call counts
#          -d              # print relative timestamps (us)
#          -e              # print elapsed times (us)
#          -f              # follow children as they are forked
#          -l              # force printing of pid/lwpid per line
#          -o              # print on cpu times (us)
#          -s              # print stack backtraces
#          -L              # don't print pid/lwpid per line
#          -b bufsize      # dynamic variable buf size (default is "4m")
#  eg,
#       dtruss df -h       # run and examine the "df -h" command
#       dtruss -p 1871     # examine PID 1871
#       dtruss -n tar      # examine all processes called "tar"
#       dtruss -f test.sh  # run test.sh and follow children
#
# The elapsed times are interesting, to help identify syscalls that take
#  some time to complete (during which the process may have context
#  switched off the CPU).
#
# SEE ALSO: procsystime    # DTraceToolkit
#           dapptrace      # DTraceToolkit
#           truss
#
# COPYRIGHT: Copyright (c) 2005 Brendan Gregg.
#
# CDDL HEADER START
#
#  The contents of this file are subject to the terms of the
#  Common Development and Distribution License, Version 1.0 only
#  (the "License").  You may not use this file except in compliance
#  with the License.
#
#  You can obtain a copy of the license at Docs/cddl1.txt
#  or http://www.opensolaris.org/os/licensing.
#  See the License for the specific language governing permissions
#  and limitations under the License.
#
# CDDL HEADER END
#
# Author: Brendan Gregg  [Sydney, Australia]
#
# TODO: Track signals, more output formatting.
#
# 29-Apr-2005   Brendan Gregg   Created this.
# 09-May-2005      "      " 	Fixed evaltime (thanks Adam L.)
# 16-May-2005	   "      "	Added -t syscall tracing.
# 17-Jun-2005	   "      "	Added -s stack backtraces.
#


##############################
# --- Process Arguments ---
#

### Default variables
opt_pid=0; opt_name=0; pid=0; pname="."
opt_elapsed=0; opt_cpu=0; opt_counts=0;
opt_relative=0; opt_printid=0; opt_follow=0
opt_command=0; command=""; opt_buf=0; buf="4m"
opt_trace=0; trace="."; opt_stack=0;

### Process options
while getopts ab:cdefhln:op:st:L name
do
        case $name in
	b)	opt_buf=1; buf=$OPTARG ;;
        p)      opt_pid=1; pid=$OPTARG ;;
        n)      opt_name=1; pname=$OPTARG ;;
        t)      opt_trace=1; trace=$OPTARG ;;
	a)	opt_counts=1; opt_relative=1; opt_elapsed=1; opt_follow=1
		opt_printid=1; opt_cpu=1 ;;
	c)	opt_counts=1 ;;
	d)	opt_relative=1 ;;
	e)	opt_elapsed=1 ;;
	f)	opt_follow=1 ;;
	l)	opt_printid=1 ;;
	o)	opt_cpu=1 ;;
	L)	opt_printid=-1 ;;
	s)	opt_stack=-1 ;;
        h|?)    cat <<-END >&2
		USAGE: dtruss [-acdefholLs] [-t syscall] { -p PID | -n name | command }

		          -p PID          # examine this PID
		          -n name         # examine this process name
		          -t syscall      # examine this syscall only
		          -a              # print all details
		          -c              # print syscall counts
		          -d              # print relative times (us)
		          -e              # print elapsed times (us)
		          -f              # follow children
		          -l              # force printing pid/lwpid
		          -o              # print on cpu times
		          -s              # print stack backtraces
		          -L              # don't print pid/lwpid
		          -b bufsize      # dynamic variable buf size
		   eg,
		       dtruss df -h       # run and examine "df -h"
		       dtruss -p 1871     # examine PID 1871
		       dtruss -n tar      # examine all processes called "tar"
		       dtruss -f test.sh  # run test.sh and follow children
		END
		exit 1
        esac
done
shift `expr $OPTIND - 1`

### Option logic
if [ $opt_pid -eq 0 -a $opt_name -eq 0 ]; then
	opt_command=1
	if [ "$*" = "" ]; then
		$0 -h
		exit
	fi
	command="$*"	# yes, I meant $*!
fi
if [ $opt_follow -eq 1 -o $opt_name -eq 1 ]; then
	if [ $opt_printid -ne -1 ]; then
		opt_printid=1
	else
		opt_printid=0
	fi
fi

### Option translation
if [ "$trace" = "exec" ]; then trace="exece"; fi


#################################
# --- Main Program, DTrace ---
#

### Define D Script
dtrace='
 #pragma D option quiet

 /*
  * Command line arguments
  */
 inline int OPT_command   = '$opt_command';
 inline int OPT_follow    = '$opt_follow';
 inline int OPT_printid   = '$opt_printid';
 inline int OPT_relative  = '$opt_relative';
 inline int OPT_elapsed   = '$opt_elapsed';
 inline int OPT_cpu       = '$opt_cpu';
 inline int OPT_counts    = '$opt_counts';
 inline int OPT_pid       = '$opt_pid';
 inline int OPT_name      = '$opt_name';
 inline int OPT_trace     = '$opt_trace';
 inline int OPT_stack     = '$opt_stack';
 inline int PID           = '$pid';
 inline string NAME       = "'$pname'";
 inline string TRACE      = "'$trace'";

 dtrace:::BEGIN
 {
	/* print header */
	OPT_printid  ? printf("%-8s  ","PID/LWP") : 1;
	OPT_relative ? printf("%8s ","RELATIVE") : 1;
	OPT_elapsed  ? printf("%7s ","ELAPSD") : 1;
	OPT_cpu      ? printf("%6s ","CPU") : 1;
	printf("SYSCALL(args) \t\t = return\n");

	/* globals */
	trackedpid[pid] = 0;
	self->child = 0;
	this->type = 0;
 }

 /*
  * Save syscall entry info
  */
 syscall:::entry
 /(OPT_command && pid == $target) ||
  (OPT_pid && pid == PID) ||
  (OPT_name && execname == NAME) ||
  (self->child)/
 {
	/* set start details */
	self->start = timestamp;
	self->vstart = vtimestamp;
	self->arg0 = arg0;
	self->arg1 = arg1;
	self->arg2 = arg2;

	/* count occurances */
	OPT_counts == 1 ? @Counts[probefunc] = count() : 1;
 }

 /*
  * Follow children
  */
 syscall::fork*:entry
 /OPT_follow && self->start/
 {
	/* track this parent process */
	trackedpid[pid] = 1;
 }
 syscall::fork*:return
 /OPT_follow && trackedpid[ppid]/
 {
	/* set as child */
	self->child = 1;
 }
 syscall::fork*:return
 /self->child && (!OPT_trace || (TRACE == probefunc))/
 {
	/* print output */
	self->code = errno == 0 ? "" : "Err#";
	OPT_printid  ? printf("%5d/%d:  ",pid,tid) : 1;
	OPT_relative ? printf("%8d:  ",vtimestamp/1000) : 1;
	OPT_elapsed  ? printf("%7d:  ",0) : 1;
	OPT_cpu      ? printf("%6d ",0) : 1;
	printf("%s(0x%X, 0x%X, 0x%X)\t\t = %d %s%d\n",probefunc,
	    self->arg0,self->arg1,self->arg2,(int)arg0,self->code,(int)errno);
 }
 syscall::rexit:entry
 {
	/* forget child */
	self->child = 0;
	trackedpid[pid] = 0;
 }

 /*
  * Check for syscall tracing
  */
 syscall:::entry
 /OPT_trace && probefunc != TRACE/
 {
	/* drop info */
	self->start = 0;
	self->vstart = 0;
	self->arg0 = 0;
	self->arg1 = 0;
	self->arg2 = 0;
 }

 /*
  * Print return data
  */

 /*
  * NOTE:
  *  The following code is written in an intentionally repetative way.
  *  The first versions had no code redundancies, but performed badly during
  *  benchmarking. The priority here is speed, not cleverness. I know there
  *  are many obvious shortcuts to this code, Ive tried them. This style has
  *  shown in benchmarks to be the fastest (fewest probes, fewest actions).
  */

 /* print 3 args, return as hex */
 syscall::lwp_sigmask:return
 /self->start/
 {
	/* calculate elapsed time */
	this->elapsed = timestamp - self->start;
	self->start = 0;
	this->cpu = vtimestamp - self->vstart;
	self->vstart = 0;
	self->code = errno == 0 ? "" : "Err#";

	/* print optional fields */
	OPT_printid  ? printf("%5d/%d:  ",pid,tid) : 1;
	OPT_relative ? printf("%8d ",vtimestamp/1000) : 1;
	OPT_elapsed  ? printf("%7d ",this->elapsed/1000) : 1;
	OPT_cpu ? printf("%6d ",this->cpu/1000) : 1;

	/* print main data */
	printf("%s(0x%X, 0x%X, 0x%X)\t\t = 0x%X %s%d\n",probefunc,
	    (int)self->arg0,self->arg1,self->arg2,(int)arg0,
	    self->code,(int)errno);
	OPT_stack ? ustack()    : 1;
	OPT_stack ? trace("\n") : 1;
	self->arg0 = 0;
	self->arg1 = 0;
	self->arg2 = 0;
 }

 /* print 3 args, arg0 as a string */
 syscall::stat*:return,
 syscall::lstat*:return,
 syscall::open*:return,
 syscall::resolvepath:return
 /self->start/
 {
	/* calculate elapsed time */
	this->elapsed = timestamp - self->start;
	self->start = 0;
	this->cpu = vtimestamp - self->vstart;
	self->vstart = 0;
	self->code = errno == 0 ? "" : "Err#";

	/* print optional fields */
	OPT_printid  ? printf("%5d/%d:  ",pid,tid) : 1;
	OPT_relative ? printf("%8d ",vtimestamp/1000) : 1;
	OPT_elapsed  ? printf("%7d ",this->elapsed/1000) : 1;
	OPT_cpu      ? printf("%6d ",this->cpu/1000) : 1;

	/* print main data */
	printf("%s(\"%S\", 0x%X, 0x%X)\t\t = %d %s%d\n",probefunc,
	    copyinstr(self->arg0),self->arg1,self->arg2,(int)arg0,
	    self->code,(int)errno);
	OPT_stack ? ustack()    : 1;
	OPT_stack ? trace("\n") : 1;
	self->arg0 = 0;
	self->arg1 = 0;
	self->arg2 = 0;
 }

 /* print 3 args, arg1 as a string */
 syscall::write:return,
 syscall::pwrite:return,
 syscall::*read*:return
 /self->start/
 {
	/* calculate elapsed time */
	this->elapsed = timestamp - self->start;
	self->start = 0;
	this->cpu = vtimestamp - self->vstart;
	self->vstart = 0;
	self->code = errno == 0 ? "" : "Err#";

	/* print optional fields */
	OPT_printid  ? printf("%5d/%d:  ",pid,tid) : 1;
	OPT_relative ? printf("%8d ",vtimestamp/1000) : 1;
	OPT_elapsed  ? printf("%7d ",this->elapsed/1000) : 1;
	OPT_cpu      ? printf("%6d ",this->cpu/1000) : 1;

	/* print main data */
	printf("%s(0x%X, \"%S\", 0x%X)\t\t = %d %s%d\n",probefunc,self->arg0,
	    stringof(copyin(self->arg1,self->arg2)),self->arg2,(int)arg0,
	    self->code,(int)errno);
	OPT_stack ? ustack()    : 1;
	OPT_stack ? trace("\n") : 1;
	self->arg0 = 0;
	self->arg1 = 0;
	self->arg2 = 0;
 }

 /* print 0 arg output */
 syscall::gtime:return,
 syscall::*fork*:return
 /self->start/
 {
	/* calculate elapsed time */
	this->elapsed = timestamp - self->start;
	self->start = 0;
	this->cpu = vtimestamp - self->vstart;
	self->vstart = 0;
	self->code = errno == 0 ? "" : "Err#";

	/* print optional fields */
	OPT_printid  ? printf("%5d/%d:  ",pid,tid) : 1;
	OPT_relative ? printf("%8d ",vtimestamp/1000) : 1;
	OPT_elapsed  ? printf("%7d ",this->elapsed/1000) : 1;
	OPT_cpu      ? printf("%6d ",this->cpu/1000) : 1;

	/* print main data */
	printf("%s()\t\t = %d %s%d\n",probefunc,
	    (int)arg0,self->code,(int)errno);
	OPT_stack ? ustack()    : 1;
	OPT_stack ? trace("\n") : 1;
	self->arg0 = 0;
	self->arg1 = 0;
	self->arg2 = 0;
 }

 /* print 1 arg output */
 syscall::brk:return,
 syscall::times:return,
 syscall::stime:return,
 syscall::close:return
 /self->start/
 {
	/* calculate elapsed time */
	this->elapsed = timestamp - self->start;
	self->start = 0;
	this->cpu = vtimestamp - self->vstart;
	self->vstart = 0;
	self->code = errno == 0 ? "" : "Err#";

	/* print optional fields */
	OPT_printid  ? printf("%5d/%d:  ",pid,tid) : 1;
	OPT_relative ? printf("%8d ",vtimestamp/1000) : 1;
	OPT_elapsed  ? printf("%7d ",this->elapsed/1000) : 1;
	OPT_cpu      ? printf("%6d ",this->cpu/1000) : 1;

	/* print main data */
	printf("%s(0x%X)\t\t = %d %s%d\n",probefunc,self->arg0,
	    (int)arg0,self->code,(int)errno);
	OPT_stack ? ustack()    : 1;
	OPT_stack ? trace("\n") : 1;
	self->arg0 = 0;
	self->arg1 = 0;
	self->arg2 = 0;
 }

 /* print 2 arg output */
 syscall::utime:return,
 syscall::munmap:return
 /self->start/
 {
	/* calculate elapsed time */
	this->elapsed = timestamp - self->start;
	self->start = 0;
	this->cpu = vtimestamp - self->vstart;
	self->vstart = 0;
	self->code = errno == 0 ? "" : "Err#";

	/* print optional fields */
	OPT_printid  ? printf("%5d/%d:  ",pid,tid) : 1;
	OPT_relative ? printf("%8d ",vtimestamp/1000) : 1;
	OPT_elapsed  ? printf("%7d ",this->elapsed/1000) : 1;
	OPT_cpu      ? printf("%6d ",this->cpu/1000) : 1;

	/* print main data */
	printf("%s(0x%X, 0x%X)\t\t = %d %s%d\n",probefunc,self->arg0,
	    self->arg1,(int)arg0,self->code,(int)errno);
	OPT_stack ? ustack()    : 1;
	OPT_stack ? trace("\n") : 1;
	self->arg0 = 0;
	self->arg1 = 0;
	self->arg2 = 0;
 }

 /* print 3 arg output - default */
 syscall:::return
 /self->start/
 {
	/* calculate elapsed time */
	this->elapsed = timestamp - self->start;
	self->start = 0;
	this->cpu = vtimestamp - self->vstart;
	self->vstart = 0;
	self->code = errno == 0 ? "" : "Err#";

	/* print optional fields */
	OPT_printid  ? printf("%5d/%d:  ",pid,tid) : 1;
	OPT_relative ? printf("%8d ",vtimestamp/1000) : 1;
	OPT_elapsed  ? printf("%7d ",this->elapsed/1000) : 1;
	OPT_cpu      ? printf("%6d ",this->cpu/1000) : 1;

	/* print main data */
	printf("%s(0x%X, 0x%X, 0x%X)\t\t = %d %s%d\n",probefunc,self->arg0,
	    self->arg1,self->arg2,(int)arg0,self->code,(int)errno);
	OPT_stack ? ustack()    : 1;
	OPT_stack ? trace("\n") : 1;
	self->arg0 = 0;
	self->arg1 = 0;
	self->arg2 = 0;
 }

 /* print counts */
 dtrace:::END
 {
	OPT_counts == 1 ? printf("\n%-32s %16s\n","CALL","COUNT") : 1;
	OPT_counts == 1 ? printa("%-32s %@16d\n",@Counts) : 1;
 }
'

### Run DTrace
if [ $opt_command -eq 1 ]; then
	/usr/sbin/dtrace -x dynvarsize=$buf -x evaltime=exec -n "$dtrace" \
	    -c "$command" >&2
else
	/usr/sbin/dtrace -x dynvarsize=$buf -n "$dtrace" >&2
fi

##############################################################
#!/usr/bin/sh
#
# procsystime - print process system call time details.
#               Written using DTrace (Solaris 10 3/05).
#
# 22-Sep-2005, ver 1.10
#
# USAGE:	procsystime [-acehoT] [ -p PID | -n name | command ]
#
#		-p PID          # examine this PID
#		-n name         # examine this process name
#		-a              # print all details
#		-c              # print syscall counts
#		-e              # print elapsed times
#		-o              # print CPU times
#		-T              # print totals
#         eg,
#		procsystime -p 1871     # examine PID 1871
#		procsystime -n tar      # examine processes called "tar"
#		procsystime -aTn bash   # print all details for bash shells
#		procsystime df -h       # run and examine "df -h"
#
# The elapsed times are interesting, to help identify syscalls that take
# some time to complete (during which the process may have slept). CPU time
# helps us identify syscalls that are consuming CPU cycles to run.
#
# FIELDS:
#		SYSCALL         System call name
#		TIME (ns)       Total time, nanoseconds
#		COUNT           Number of occurrences
#
# COPYRIGHT: Copyright (c) 2005 Brendan Gregg.
#
# CDDL HEADER START
#
#  The contents of this file are subject to the terms of the
#  Common Development and Distribution License, Version 1.0 only
#  (the "License").  You may not use this file except in compliance
#  with the License.
#
#  You can obtain a copy of the license at Docs/cddl1.txt
#  or http://www.opensolaris.org/os/licensing.
#  See the License for the specific language governing permissions
#  and limitations under the License.
#
# CDDL HEADER END
#
# Author: Brendan Gregg  [Sydney, Australia]
#
# 27-Apr-2005   Brendan Gregg   Created this.
# 08-Jun-2005	   "      "	Added command option.
# 22-Sep-2005	   "      "	Allowed systemwide tracing.
#


##############################
# --- Process Arguments ---
#

### Default variables
opt_filter=0; opt_pid=0; opt_name=0; pid=0; pname=".";
opt_elapsed=0; opt_cpu=0; opt_counts=0; opt_totals=0
opt_command=0; command="";

### Process options
while getopts acehn:op:T name
do
        case $name in
        p)      opt_filter=1; opt_pid=1; pid=$OPTARG ;;
        n)      opt_filter=1; opt_name=1; pname=$OPTARG ;;
	a)	opt_totals=1; opt_elapsed=1; opt_cpu=1; opt_counts=1 ;;
	e)	opt_elapsed=1 ;;
	c)	opt_counts=1 ;;
	o)	opt_cpu=1 ;;
	T)	opt_totals=1 ;;
        h|?)    cat <<-END >&2
		USAGE: procsystime [-aceho] [ -p PID | -n name | command ]
		                  -p PID          # examine this PID
		                  -n name         # examine this process name
		                  -a              # print all details
		                  -e              # print elapsed times
		                  -c              # print syscall counts
		                  -o              # print CPU times
		                  -T              # print totals
		  eg,
		       procsystime -p 1871     # examine PID 1871
		       procsystime -n tar      # examine processes called "tar"
		       procsystime -aTn bash   # print all details for bash
		       procsystime df -h       # run and examine "df -h"
		END
		exit 1
        esac
done
shift `expr $OPTIND - 1`

### Option logic
if [ $opt_pid -eq 0 -a $opt_name -eq 0 -a "$*" != "" ]; then
	opt_filter=1
	opt_command=1
	command="$*"
fi
if [ $opt_elapsed -eq 0 -a $opt_cpu -eq 0 -a $opt_counts -eq 0 ]; then
	opt_elapsed=1;
fi


#################################
# --- Main Program, DTrace ---
#
dtrace='
 #pragma D option quiet

 /*
  * Command line arguments
  */
 inline int OPT_elapsed  = '$opt_elapsed';
 inline int OPT_cpu      = '$opt_cpu';
 inline int OPT_counts   = '$opt_counts';
 inline int OPT_filter   = '$opt_filter';
 inline int OPT_pid      = '$opt_pid';
 inline int OPT_name     = '$opt_name';
 inline int OPT_totals   = '$opt_totals';
 inline int OPT_command  = '$opt_command';
 inline int PID          = '$pid';
 inline string NAME      = "'$pname'";
 inline string COMMAND   = "'$command'";

 dtrace:::BEGIN
 {
	self->start = 0;
	self->vstart = 0;
 }
 dtrace:::BEGIN
 /! OPT_command/
 {
	printf("Hit Ctrl-C to stop sampling...\n");
 }

 /*
  * Set start timestamp and counts
  */
 syscall:::entry
 /(! OPT_filter) ||
  (OPT_pid && pid == PID) ||
  (OPT_name && execname == NAME) ||
  (OPT_command && pid == $target)/
 {
	self->ok = 1;
 }
 syscall:::entry
 /self->ok/
 {
	OPT_counts ? @Counts[probefunc] = count() : 1;
	(OPT_counts && OPT_totals) ? @Counts["TOTAL:"] = count() : 1;
	OPT_elapsed ? self->start = timestamp : 1;
	OPT_cpu ? self->vstart = vtimestamp : 1;
	self->ok = 0;
 }

 /*
  * Calculate time deltas
  */
 syscall:::return
 /self->start/
 {
	this->elapsed = timestamp - self->start;
	@Elapsed[probefunc] = sum(this->elapsed);
	OPT_totals ? @Elapsed["TOTAL:"] = sum(this->elapsed) : 1;
	self->start = 0;
 }
 syscall:::return
 /self->vstart/
 {
	this->cpu = vtimestamp - self->vstart;
	@CPU[probefunc] = sum(this->cpu);
	OPT_totals ? @CPU["TOTAL:"] = sum(this->cpu) : 1;
	self->vstart = 0;
 }

 /*
  * Elapsed time report
  */
 dtrace:::END
 /OPT_elapsed/
 {
	printf("\nElapsed Times for ");
	OPT_pid ? printf("PID %d,\n\n",PID) : 1;
	OPT_name ? printf("processes %s,\n\n",NAME) : 1;
	OPT_command ? printf("command %s,\n\n",COMMAND) : 1;
	(! OPT_filter) ? printf("all processes,\n\n") : 1;
	printf("%16s %18s\n","SYSCALL","TIME (ns)");
	printa("%16s %@18d\n",@Elapsed);
 }

 /*
  * CPU time report
  */
 dtrace:::END
 /OPT_cpu/
 {
	printf("\nCPU Times for ");
	OPT_pid ? printf("PID %d,\n\n",PID) : 1;
	OPT_name ? printf("processes %s,\n\n",NAME) : 1;
	OPT_command ? printf("command %s,\n\n",COMMAND) : 1;
	(! OPT_filter) ? printf("all processes,\n\n") : 1;
	printf("%16s %18s\n","SYSCALL","TIME (ns)");
	printa("%16s %@18d\n",@CPU);
 }

 /*
  * Syscall count report
  */
 dtrace:::END
 /OPT_counts/
 {
	printf("\nSyscall Counts for ");
	OPT_pid ? printf("PID %d,\n\n",PID) : 1;
	OPT_name ? printf("processes %s,\n\n",NAME) : 1;
	OPT_command ? printf("command %s,\n\n",COMMAND) : 1;
	(! OPT_filter) ? printf("all processes,\n\n") : 1;
	printf("%16s %18s\n","SYSCALL","COUNT");
	OPT_counts ? printa("%16s %@18d\n",@Counts) : 1;
 }
'

### Run DTrace
if [ $opt_command -eq 1 ]; then
	/usr/sbin/dtrace -n "$dtrace" -x evaltime=exec -c "$command" >&2
else
	/usr/sbin/dtrace -n "$dtrace" >&2
fi

##############################################################
#!/usr/bin/perl -w
#
# hotuser - sample on-CPU user-level functions and libraries.
#           Written using Perl and DTrace (Solaris 10 03/05)
#
# This samples the on-CPU function at 1000 Hertz, for a simple yet
# effective user-level profiling tool. The output will identify which
# function is on the CPU the most - which is the hottest.
#
# 29-Jun-2006, ver 0.70
#
# USAGE:        hotuser [-hl] { -c command | -p PID }
#
#               -h              # help
#               -l              # match libraries, not functions
#               -p PID          # examine this PID
#               -c command      # run and examine this command
#       eg,
#               hotuser -p 81   # sample user functions from PID 81
#               hotuser -lp 81  # sample user libraries from PID 81
#               hotuser -p `pgrep -n Xorg`	# sample Xorg
#
# FIELDS:
#               FUNCTION        Function name
#               LIBRARY         Library name
#               COUNT           Number of samples
#               PCNT            Percentage of total samples
#
# COPYRIGHT: Copyright (c) 2006 Brendan Gregg.
#
# CDDL HEADER START
#
#  The contents of this file are subject to the terms of the
#  Common Development and Distribution License, Version 1.0 only
#  (the "License").  You may not use this file except in compliance
#  with the License.
#
#  You can obtain a copy of the license at Docs/cddl1.txt
#  or http://www.opensolaris.org/os/licensing.
#  See the License for the specific language governing permissions
#  and limitations under the License.
#
# CDDL HEADER END
#
# Author: Brendan Gregg  [Sydney, Australia]
#
# 29-Jun-2006   Brendan Gregg   Created this.
#

use strict;
use Getopt::Std;

#
# Command Line Arguments
#
my $args;
usage() if defined $ARGV[0] and $ARGV[0] eq "--help";
getopts('c:hlp:') or usage();
usage() if defined $main::opt_h and $main::opt_h;
my $libs = defined $main::opt_l and $main::opt_l ? 1 : 0;
if (defined $main::opt_c) {
    $args = "-c $main::opt_c";
}
elsif (defined $main::opt_p) {
    $args = "-p $main::opt_p";
}
else {
    usage();
}

#
# Cleanup on signals
#
$SIG{INT} = \&cleanupsig;    # Ctrl-C
$SIG{QUIT} = \&cleanupsig;   # Ctrl-\
$SIG{TERM} = \&cleanupsig;   # TERM

#
# Declare DTrace script
#
my $dtrace = <<END;
/usr/sbin/dtrace -n '
	#pragma D option quiet
	profile:::profile-1000hz
	/pid == \$target/
	{
		\@pc[arg1] = count();
	}
	dtrace:::END
	{
		printa("OUT: %A %\@d\\n", \@pc);
	}
' '$args'
END

#
# Run DTrace, process output
#
my %Count;
my $total;
open DTRACE, "$dtrace |" or die "ERROR1: Can't run dtrace (perms?): $!\n";
print "Sampling... Hit Ctrl-C to end.\n";
while (my $line = <DTRACE>) {
    next if $line =~ /^\s*$/;
    next if $line !~ /^OUT: /;
    my ($tag, $addr, $count) = split ' ', $line;
    my ($name, $offset) = split /\+/, $addr;
    next if $name eq "0x0";
    $name =~ s/\`.*// if $libs;
    $Count{$name} += $count;
    $total += $count;
}
close DTRACE;

#
# Print final report
#
printf "\n%-52s %8s %6s\n", $libs ? "LIBRARY" : "FUNCTION", "COUNT", "PCNT";
foreach my $name (sort { $Count{$a} <=> $Count{$b} } keys %Count) {
    printf "%-52s %8d %5.1f%%\n", $name, $Count{$name},
                                  100 * $Count{$name} / ($total ? $total : 1);
}

#
# Subroutines
#
sub cleanupsig {
}
sub usage {
    print STDERR "USAGE: hotuser [-hl] { -c command | -p PID }\n";
    print STDERR "   eg,\n";
    print STDERR "       hotuser -p 81     # sample user funcs for PID 81\n";
    print STDERR "       hotuser -lp 81    # sample user libs for PID 81\n";
    print STDERR "       hotuser -p `pgrep -n Xorg`     # sample Xorg\n";
    exit 1;
}
##############################################################
#!/usr/bin/perl -w
#
# hotkernel - sample on-CPU kernel-level functions and modules.
#             Written using Perl and DTrace (Solaris 10 03/05)
#
# This samples the on-CPU function at 1001 Hertz, for a simple yet
# effective kernel-level profiling tool. The output will identify which
# function is on the CPU the most - which is the hottest.
#
# 29-Jun-2006, ver 0.70
#
# USAGE:        hotkernel [-hm]
#
#               -h              # help
#               -m              # match modules, not functions
#       eg,
#               hotkernel       # sample kernel functions
#               hotkernel -m    # sample kernel modules
#
# FIELDS:
#               FUNCTION        Function name
#               MODULE          Module name
#               COUNT           Number of samples
#               PCNT            Percentage of total samples
#
# COPYRIGHT: Copyright (c) 2006 Brendan Gregg.
#
# CDDL HEADER START
#
#  The contents of this file are subject to the terms of the
#  Common Development and Distribution License, Version 1.0 only
#  (the "License").  You may not use this file except in compliance
#  with the License.
#
#  You can obtain a copy of the license at Docs/cddl1.txt
#  or http://www.opensolaris.org/os/licensing.
#  See the License for the specific language governing permissions
#  and limitations under the License.
#
# CDDL HEADER END
#
# Author: Brendan Gregg  [Sydney, Australia]
#
# 29-Jun-2006   Brendan Gregg   Created this.
#

use strict;
use Getopt::Std;

#
# Command Line Arguments
#
my $args;
usage() if defined $ARGV[0] and $ARGV[0] eq "--help";
getopts('hm') or usage();
usage() if defined $main::opt_h and $main::opt_h;
my $mods = defined $main::opt_m and $main::opt_m ? 1 : 0;

#
# Cleanup on signals
#
$SIG{INT} = \&cleanupsig;    # Ctrl-C
$SIG{QUIT} = \&cleanupsig;   # Ctrl-\
$SIG{TERM} = \&cleanupsig;   # TERM

#
# Declare DTrace script
#
my $dtrace = <<END;
/usr/sbin/dtrace -n '
	#pragma D option quiet
	profile:::profile-1001hz
	/arg0/
	{
		\@pc[arg0] = count();
	}
	dtrace:::END
	{
		printa("%a %\@d\\n", \@pc);
	}
'
END

#
# Run DTrace, process output
#
my %Count;
my $total;
open DTRACE, "$dtrace |" or die "ERROR1: Can't run dtrace (perms?): $!\n";
print "Sampling... Hit Ctrl-C to end.\n";
while (my $line = <DTRACE>) {
    next if $line =~ /^\s*$/;
    my ($addr, $count) = split ' ', $line;
    my ($name, $offset) = split /\+/, $addr;
    next if $name eq "0x0";
    $name =~ s/\`.*// if $mods;
    $Count{$name} += $count;
    $total += $count;
}
close DTRACE;

#
# Print final report
#
printf "\n%-52s %8s %6s\n", $mods ? "MODULE" : "FUNCTION", "COUNT", "PCNT";
foreach my $name (sort { $Count{$a} <=> $Count{$b} } keys %Count) {
    printf "%-52s %8d %5.1f%%\n", $name, $Count{$name},
                                  100 * $Count{$name} / ($total ? $total : 1);
}

#
# Subroutines
#
sub cleanupsig {
}
sub usage {
    print STDERR "USAGE: hotkernel [-hm]\n";
    print STDERR "   eg,\n";
    print STDERR "       hotkernel       # sample kernel functions\n";
    print STDERR "       hotkernel -m    # sample kernel modules\n";
    exit 1;
}
##############################################################
#!/usr/bin/sh
#
# dapptrace - trace user and library function usage.
#             Written using DTrace (Solaris 10 3/05).
#
# The default output traces user functions as they are called. Options
#  can be used to examine libraries and timestamps.
#
# 17-Jun-2005, ver 0.61         (early release! check for newer versions)
#
# USAGE: dapptrace [-acdeFlhoU] [-u lib] { -p PID | command }
#
#          -p PID          # examine this PID
#          -a              # print all details
#          -c              # print call counts
#          -d              # print relative timestamps (us)
#          -e              # print elapsed times (us)
#          -F              # print flow indentation
#          -l              # print pid/lwpid per line
#          -o              # print on cpu times (us)
#          -u lib          # trace this library instead
#          -U              # trace all libraries + user functions
#          -b bufsize      # dynamic variable buf size (default is "4m")
#  eg,
#       dapptrace df -h       # run and examine the "df -h" command
#       dapptrace -p 1871     # examine PID 1871
#       dapptrace -Fp 1871    # print using flow indents
#       dapptrace -eop 1871   # print elapsed and CPU times
#
# The elapsed times are interesting, to help identify calls that take
#  some time to complete (during which the process may have context
#  switched off the CPU).
#
# SEE ALSO: dappprof       # DTraceToolkit
#           dtruss         # DTraceToolkit
#           apptrace
#
# COPYRIGHT: Copyright (c) 2005 Brendan Gregg.
#
# CDDL HEADER START
#
#  The contents of this file are subject to the terms of the
#  Common Development and Distribution License, Version 1.0 only
#  (the "License").  You may not use this file except in compliance
#  with the License.
#
#  You can obtain a copy of the license at Docs/cddl1.txt
#  or http://www.opensolaris.org/os/licensing.
#  See the License for the specific language governing permissions
#  and limitations under the License.
#
# CDDL HEADER END
#
# Author: Brendan Gregg  [Sydney, Australia]
#
# 16-May-2005   Brendan Gregg   Created this.
#


##############################
# --- Process Arguments ---
#

### Default variables
opt_pid=0; pid=0; opt_indent=0; opt_lib=0; lib=""
opt_elapsed=0; opt_cpu=0; opt_counts=0;
opt_relative=0; opt_printid=0; opt_liball=0
opt_command=0; command=""; opt_buf=0; buf="4m"

### Process options
while getopts ab:cdeFhlop:u:U name
do
        case $name in
        a)      opt_liball=1; opt_counts=1; opt_relative=1; opt_elapsed=1
		opt_indent=1; opt_printid=1; opt_cpu=1 ;;
	b)	opt_buf=1; buf=$OPTARG ;;
        p)      opt_pid=1; pid=$OPTARG ;;
        u)      opt_lib=1; lib=$OPTARG ;;
        U)      opt_liball=1 ;;
	c)	opt_counts=1 ;;
	d)	opt_relative=1 ;;
	e)	opt_elapsed=1 ;;
	F)	opt_indent=1 ;;
	l)	opt_printid=1 ;;
	o)	opt_cpu=1 ;;
        h|?)    cat <<-END >&2
		USAGE: dapptrace [-acdeholFLU] [-u lib] { -p PID | command }

		          -p PID          # examine this PID
		          -a              # print all details
		          -c              # print syscall counts
		          -d              # print relative times (us)
		          -e              # print elapsed times (us)
		          -F              # print flow indentation
		          -l              # print pid/lwpid
		          -o              # print CPU on cpu times
		          -u lib          # trace this library instead
		          -U              # trace all libraries + user funcs
		          -b bufsize      # dynamic variable buf size
		   eg,
		       dapptrace df -h       # run and examine "df -h"
		       dapptrace -p 1871     # examine PID 1871
		       dapptrace -Fp 1871    # print using flow indents
		       dapptrace -eop 1871   # print elapsed and CPU times
		END
		exit 1
        esac
done
shift `expr $OPTIND - 1`

### Option logic
if [ $opt_pid -eq 0 ]; then
	opt_command=1
	if [ "$*" = "" ]; then
		$0 -h
		exit
	fi
	command="$*"
fi

### Probe logic
if [ $opt_liball -eq 1 ]; then
	probe_entry='pid$target:::entry'
	probe_return='pid$target:::return'
elif [ $opt_lib -eq 1 ]; then
	probe_entry='pid$target:'$lib'::entry'
	probe_return='pid$target:'$lib'::return'
else
 	probe_entry='pid$target:a.out::entry'
 	probe_return='pid$target:a.out::return'
fi

#################################
# --- Main Program, DTrace ---
#

### Define D Script
dtrace='
 #pragma D option quiet

 /*
  * Command line arguments
  */
 inline int OPT_command   = '$opt_command';
 inline int OPT_liball    = '$opt_liball';
 inline int OPT_indent    = '$opt_indent';
 inline int OPT_printid   = '$opt_printid';
 inline int OPT_relative  = '$opt_relative';
 inline int OPT_elapsed   = '$opt_elapsed';
 inline int OPT_cpu       = '$opt_cpu';
 inline int OPT_counts    = '$opt_counts';
 inline int OPT_pid       = '$opt_pid';
 inline int PID           = '$pid';
 inline string NAME       = "'$pname'";

 dtrace:::BEGIN
 {
	/* print header */
	OPT_printid  ? printf("%-8s  ","PID/LWP") : 1;
	OPT_relative ? printf("%8s ","RELATIVE") : 1;
	OPT_elapsed  ? printf("%7s ","ELAPSD") : 1;
	OPT_cpu      ? printf("%6s ","CPU") : 1;
	printf("CALL(args) \t\t = return\n");

	/* indent depth */
	depth = 0;
 }

 /*
  * Save syscall entry info
  */
 '$probe_entry'
 {
	/* set function depth */
	this->fdepth = ++fdepth[probefunc];
	depth += 2;

	/* set start details */
	self->start[probefunc,this->fdepth] = timestamp;
	self->vstart[probefunc,this->fdepth] = vtimestamp;

	/* count occurances */
	OPT_counts && OPT_liball ? @Counts[probemod,probefunc] = count() : 1;
	OPT_counts && ! OPT_liball ? @Counts[probefunc] = count() : 1;

	/* print optional fields */
	OPT_printid  ? printf("%5d/%d:  ",pid,tid) : 1;
	OPT_relative ? printf("%8d ",vtimestamp/1000) : 1;
	OPT_elapsed  ? printf("      . ") : 1;
	OPT_cpu      ? printf("     . ") : 1;
	OPT_indent   ? printf("%*s",depth,"") : 1;

	/* print main data */
	printf("-> ");
	OPT_liball ? printf("%s:",probemod) : 1;
	printf("%s(0x%X, 0x%X, 0x%X)\t\t\n",probefunc,arg0,arg1,arg2);

 }

 /*
  * Print return data
  */
 /* print 3 arg output - default */
 '$probe_return'
 /self->start[probefunc,fdepth[probefunc]]/
 {
	/* fetch function depth */
	this->fdepth = fdepth[probefunc];

	/* calculate elapsed time */
	this->elapsed = timestamp - self->start[probefunc,this->fdepth];
	self->start[probefunc,this->fdepth] = 0;
	this->cpu = vtimestamp - self->vstart[probefunc,this->fdepth];
	self->vstart[probefunc,this->fdepth] = 0;

	/* print optional fields */
	OPT_printid  ? printf("%5d/%d:  ",pid,tid) : 1;
	OPT_relative ? printf("%8d ",vtimestamp/1000) : 1;
	OPT_elapsed  ? printf("%7d ",this->elapsed/1000) : 1;
	OPT_cpu      ? printf("%6d ",this->cpu/1000) : 1;
	OPT_indent   ? printf("%*s",depth,"") : 1;

	/* print main data */
	printf("<- ");
	OPT_liball ? printf("%s:",probemod) : 1;
	printf("%s = %d\n",probefunc,(int)arg0);
	depth -= 2;
	fdepth[probefunc]--;
 }

 /* reset indent depth */
 profile:::tick-1sec
 {
	/*
	 * some probes generated by the pid provider have entries
 	 * but not returns. this is a klude to fix that problem. this
	 * also explains fdepth[probefunc] rather than a single depth.
	 */
	depth = 0;
 }

 /* print counts */
 dtrace:::END
 {
	OPT_counts ? printf("\n%-49s %16s\n","CALL","COUNT") : 1;
	OPT_counts && OPT_liball ? printa("%-16s %-32s %@16d\n",@Counts) : 1;
	OPT_counts && ! OPT_liball ? printa("%-49s %@16d\n",@Counts) : 1;
 }
'

### Run DTrace
if [ $opt_command -eq 1 ]; then
	/usr/sbin/dtrace -x dynvarsize=$buf -x evaltime=exec -n "$dtrace" \
	    -c "$command" >&2
else
	/usr/sbin/dtrace -x dynvarsize=$buf -n "$dtrace" -p "$pid" >&2
fi

##############################################################
#!/usr/bin/sh
#
# dappprof - profile user and library function usage.
#            Written using DTrace (Solaris 10 3/05).
#
# The default output traces user functions as they are called. Options
#  can be used to examine libraries and timestamps.
#
# 17-Jul-2005, ver 0.62         (early release! check for newer versions)
#
# USAGE: dappprof [-acehoTU] [-u lib] { -p PID | command }
#
#          -p PID          # examine this PID
#          -a              # print all details
#          -c              # print call counts
#          -e              # print elapsed times (us)
#          -o              # print on cpu times (us)
#          -T              # print totals
#          -u lib          # trace this library instead
#          -U              # trace all libraries + user functions
#          -b bufsize      # dynamic variable buf size (default is "4m")
#  eg,
#       dappprof df -h       # run and examine the "df -h" command
#       dappprof -p 1871     # examine PID 1871
#
# The elapsed times are interesting, to help identify calls that take
#  some time to complete (during which the process may have context
#  switched off the CPU).
#
# SEE ALSO: dapptrace      # DTraceToolkit
#           dtruss         # DTraceToolkit
#           apptrace
#
# COPYRIGHT: Copyright (c) 2005 Brendan Gregg.
#
# CDDL HEADER START
#
#  The contents of this file are subject to the terms of the
#  Common Development and Distribution License, Version 1.0 only
#  (the "License").  You may not use this file except in compliance
#  with the License.
#
#  You can obtain a copy of the license at Docs/cddl1.txt
#  or http://www.opensolaris.org/os/licensing.
#  See the License for the specific language governing permissions
#  and limitations under the License.
#
# CDDL HEADER END
#
# Author: Brendan Gregg  [Sydney, Australia]
#
# 16-May-2005   Brendan Gregg   Created this.
#


##############################
# --- Process Arguments ---
#

### Default variables
opt_totals=0; opt_pid=0; pid=0; opt_lib=0; lib=""
opt_elapsed=0; opt_cpu=0; opt_counts=0; opt_liball=0
opt_command=0; command=""; opt_buf=0; buf="4m"

### Process options
while getopts ab:cehop:Tu:U name
do
        case $name in
        a)      opt_liball=1; opt_counts=1; opt_elapsed=1; opt_cpu=1
		opt_totals=1 ;;
	b)	opt_buf=1; buf=$OPTARG ;;
        p)      opt_pid=1; pid=$OPTARG ;;
        u)      opt_lib=1; lib=$OPTARG ;;
        U)      opt_liball=1 ;;
	c)	opt_counts=1 ;;
	e)	opt_elapsed=1 ;;
	o)	opt_cpu=1 ;;
	T)	opt_totals=1 ;;
        h|?)    cat <<-END >&2
		USAGE: dappprof [-cehoTU] [-u lib] { -p PID | command }

		          -p PID          # examine this PID
		          -a              # print all details
		          -c              # print syscall counts
		          -e              # print elapsed times (us)
		          -o              # print on cpu times
		          -T              # print totals
		          -u lib          # trace this library instead
		          -U              # trace all libraries + user funcs
		          -b bufsize      # dynamic variable buf size
		   eg,
		       dappprof df -h       # run and examine "df -h"
		       dappprof -p 1871     # examine PID 1871
		       dappprof -ap 1871    # print all data
		END
		exit 1
        esac
done
shift `expr $OPTIND - 1`

### Option logic
if [ $opt_pid -eq 0 ]; then
	opt_command=1
	if [ "$*" = "" ]; then
		$0 -h
		exit
	fi
	command="$*"
fi
if [ $opt_elapsed -eq 0 -a $opt_cpu -eq 0 -a $opt_counts -eq 0 ]; then
        opt_elapsed=1;
fi


### Probe logic
if [ $opt_liball -eq 1 ]; then
	probe_entry='pid$target:::entry'
	probe_return='pid$target:::return'
elif [ $opt_lib -eq 1 ]; then
	probe_entry='pid$target:'$lib'::entry'
	probe_return='pid$target:'$lib'::return'
else
 	probe_entry='pid$target:a.out::entry'
 	probe_return='pid$target:a.out::return'
fi

#################################
# --- Main Program, DTrace ---
#

### Define D Script
dtrace='
 #pragma D option quiet

 /*
  * Command line arguments
  */
 inline int OPT_command   = '$opt_command';
 inline int OPT_liball    = '$opt_liball';
 inline int OPT_elapsed   = '$opt_elapsed';
 inline int OPT_cpu       = '$opt_cpu';
 inline int OPT_counts    = '$opt_counts';
 inline int OPT_totals    = '$opt_totals';
 inline int OPT_pid       = '$opt_pid';
 inline int PID           = '$pid';
 inline string NAME       = "'$pname'";

 dtrace:::BEGIN
 /! OPT_command/
 {
	printf("Hit Ctrl-C to stop sampling...\n");
 }

 /*
  * Save syscall entry info
  */
 '$probe_entry'
 {
        /* set function depth */
        this->fdepth = ++fdepth[probefunc];

	/* set start details */
	self->start[probefunc,this->fdepth] = timestamp;
	self->vstart[probefunc,this->fdepth] = vtimestamp;

	/* count occurances */
	OPT_counts && OPT_liball ? @Counts[probemod,probefunc] = count() : 1;
	OPT_counts && ! OPT_liball ? @Counts[probefunc] = count() : 1;
	OPT_counts && OPT_totals && OPT_liball ?
	    @Counts["TOTAL:",""] = count() : 1;
	OPT_counts && OPT_totals && ! OPT_liball ?
	    @Counts["TOTAL:"] = count() : 1;
 }

 /*
  * Print return data
  */
 /* print 3 arg output - default */
 '$probe_return'
 /self->start[probefunc,fdepth[probefunc]]/
 {
        /* fetch function depth */
        this->fdepth = fdepth[probefunc];

	/* calculate elapsed time */
	this->elapsed = timestamp - self->start[probefunc,this->fdepth];
	self->start[probefunc,this->fdepth] = 0;
	this->cpu = vtimestamp - self->vstart[probefunc,this->fdepth];
	self->vstart[probefunc,this->fdepth] = 0;

	/* save elapsed times */
	OPT_elapsed && OPT_liball ?
	    @Elapsed[probemod,probefunc] = sum(this->elapsed) : 1;
	OPT_elapsed && ! OPT_liball ?
	    @Elapsed[probefunc] = sum(this->elapsed) : 1;
	OPT_elapsed && OPT_totals && OPT_liball ?
	    @Elapsed["TOTAL:",""] = sum(this->elapsed) : 1;
	OPT_elapsed && OPT_totals && ! OPT_liball ?
	    @Elapsed["TOTAL:"] = sum(this->elapsed) : 1;

	/* save cpu times */
	OPT_cpu && OPT_liball ? @CPU[probemod,probefunc] = sum(this->cpu) : 1;
	OPT_cpu && ! OPT_liball ? @CPU[probefunc] = sum(this->cpu) : 1;
	OPT_cpu && OPT_totals && OPT_liball ?
	    @CPU["TOTAL:",""] = sum(this->cpu) : 1;
	OPT_cpu && OPT_totals && ! OPT_liball ?
	    @CPU["TOTAL:"] = sum(this->cpu) : 1;

 }

 /* print counts */
 dtrace:::END
 {
	/* print counts */
	OPT_counts ? printf("\n%-49s %16s\n","CALL","COUNT") : 1;
	OPT_counts && OPT_liball ? printa("%-16s %-32s %@16d\n",@Counts) : 1;
	OPT_counts && ! OPT_liball ? printa("%-49s %@16d\n",@Counts) : 1;

	/* print elapsed times */
	OPT_elapsed ? printf("\n%-49s %16s\n","CALL","ELAPSED") : 1;
	OPT_elapsed && OPT_liball ? printa("%-16s %-32s %@16d\n",@Elapsed) : 1;
	OPT_elapsed && ! OPT_liball ? printa("%-49s %@16d\n",@Elapsed) : 1;

	/* print cpu times */
	OPT_cpu ? printf("\n%-49s %16s\n","CALL","CPU") : 1;
	OPT_cpu && OPT_liball ? printa("%-16s %-32s %@16d\n",@CPU) : 1;
	OPT_cpu && ! OPT_liball ? printa("%-49s %@16d\n",@CPU) : 1;
 }
'

### Run DTrace
if [ $opt_command -eq 1 ]; then
	/usr/sbin/dtrace -x dynvarsize=$buf -x evaltime=exec -n "$dtrace" \
	    -c "$command" >&2
else
	/usr/sbin/dtrace -x dynvarsize=$buf -n "$dtrace" -p "$pid" >&2
fi

##############################################################
#!/usr/bin/sh
#
# dvmstat - vmstat by PID/name/command.
#           Written using DTrace (Solaris 10 3/05).
#
# This program provides vmstat like data for one particular PID, a
# process name, or when running a command. It prints statistics
# every second.
#
# 12-Jun-2005, ver 0.70        (first release. check for newer versions)
#
# USAGE:       dvmstat { -p PID | -n name | command }
#    eg,
#              dvmstat -p 1871       # examine PID 1871
#              dvmstat -n tar        # examine processes called "tar"
#              dvmstat df -h         # run and examine "df -h"
#
# FIELDS:
#
#       re     page reclaims         Kb
#       maj    major faults          Kb
#       mf     minor faults          Kb
#       fr     page frees            Kb
#       epi    executable page ins   Kb
#       epo    executable page outs  Kb
#       api    anonymous page ins    Kb
#       apo    anonymous page outs   Kb
#       fpi    filesystem page ins   Kb
#       fpo    filesystem page outs  Kb
#       sy     system calls          number
#
# SEE ALSO:	vmstat(1M)
#
# NOTES:
# * When using dvmstat to run a command - if the command takes some time
# to execute, dvmstat will print output every second. If the command runs
# in less than a second, then the only one line of output will be printed.
#
# COPYRIGHT: Copyright (c) 2005 Brendan Gregg.
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#  (http://www.gnu.org/copyleft/gpl.html)
#
# Author: Brendan Gregg  [Sydney, Australia]
#
# 12-Jun-2005  Brendan Gregg   Created this.
#

#pragma D option quiet

##############################
# --- Process Arguments ---
#

### Default variables
opt_pid=0; opt_name=0; pid=0; pname="."; opt_command=0; command=""

### Process options
while getopts hn:p: name
do
        case $name in
        p)      opt_pid=1; pid=$OPTARG ;;
        n)      opt_name=1; pname=$OPTARG ;;
        h|?)    cat <<-END >&2
		USAGE: dvmstat [-h] { -p PID | -n name | command }
		           -p PID          # examine this PID
		           -n name         # examine this process name
		  eg,
		       dvmstat -p 1871     # examine PID 1871
		       dvmstat -n tar      # examine processes called "tar"
		       dvmstat df -h       # run and examine "df -h"
		END
                exit 1
        esac
done
shift `expr $OPTIND - 1`


### Option logic
if [ $opt_pid -eq 0 -a $opt_name -eq 0 ]; then
        opt_command=1
        if [ "$*" = "" ]; then
                $0 -h
                exit
        fi
        command="$*"
fi


#################################
# --- Main Program, DTrace ---
#
dtrace='
 #pragma D option quiet

 /*
  * Command line arguments
  */
 inline int OPT_pid      = '$opt_pid';
 inline int OPT_name     = '$opt_name';
 inline int OPT_command  = '$opt_command';
 inline int PID          = '$pid';
 inline string NAME      = "'$pname'";
 inline string COMMAND   = "'$command'";
 inline int SCREEN       = 21;

 /*
  * Initialise variables
  */
 dtrace:::BEGIN
 {
	epi = 0; epo = 0; api = 0; apo = 0; fpi = 0; fpo = 0;
	re = 0; mf = 0; maj = 0; fr = 0; sy = 0;
	lines = SCREEN + 1;
	header = 0;
 }

 /*
  * Print header
  */
 dtrace:::BEGIN,
 dtrace:::END,
 profile:::tick-1sec
 /(OPT_command && probename == "END") ||
  (!(OPT_command && probename == "BEGIN") && lines++ > SCREEN)/
 {
	printf("%6s %5s %5s %4s %4s %4s %4s %4s %4s %4s %6s\n",
	    "re", "maj", "mf", "fr", "epi", "epo", "api", "apo",
	    "fpi", "fpo", "sy");
	lines = 0;
 }

 /*
  * Probe events
  *
  * this intentionally does not use an associative array for storing data,
  * for reasons of performance.
  */

 vminfo:::execpgin
 /(OPT_pid && pid == PID) ||
  (OPT_name && execname == NAME) ||
  (OPT_command && pid == $target)/
 { epi += arg0; }

 vminfo:::execpgout
 /(OPT_pid && pid == PID) ||
  (OPT_name && execname == NAME) ||
  (OPT_command && pid == $target)/
 { epo += arg0; }

 vminfo:::anonpgin
 /(OPT_pid && pid == PID) ||
  (OPT_name && execname == NAME) ||
  (OPT_command && pid == $target)/
 { api += arg0; }

 vminfo:::anonpgout
 /(OPT_pid && pid == PID) ||
  (OPT_name && execname == NAME) ||
  (OPT_command && pid == $target)/
 { apo += arg0; }

 vminfo:::fspgin
 /(OPT_pid && pid == PID) ||
  (OPT_name && execname == NAME) ||
  (OPT_command && pid == $target)/
 { fpi += arg0; }

 vminfo:::fspgout
 /(OPT_pid && pid == PID) ||
  (OPT_name && execname == NAME) ||
  (OPT_command && pid == $target)/
 { fpo += arg0; }

 vminfo:::pgrec
 /(OPT_pid && pid == PID) ||
  (OPT_name && execname == NAME) ||
  (OPT_command && pid == $target)/
 { re += arg0; }

 vminfo:::as_fault
 /(OPT_pid && pid == PID) ||
  (OPT_name && execname == NAME) ||
  (OPT_command && pid == $target)/
 { mf += arg0; }

 vminfo:::maj_fault
 /(OPT_pid && pid == PID) ||
  (OPT_name && execname == NAME) ||
  (OPT_command && pid == $target)/
 { maj += arg0; }

 vminfo:::dfree
 /(OPT_pid && pid == PID) ||
  (OPT_name && execname == NAME) ||
  (OPT_command && pid == $target)/
 { fr += arg0; }

 syscall:::entry
 /(OPT_pid && pid == PID) ||
  (OPT_name && execname == NAME) ||
  (OPT_command && pid == $target)/
 { sy++; }

 /*
  * Print output line
  */
 profile:::tick-1sec,
 dtrace:::END
 {
	/* convert to kb */
	re  *= `pagesize / 1024;
	maj *= `pagesize / 1024;
	mf  *= `pagesize / 1024;
	fr  *= `pagesize / 1024;
	epi *= `pagesize / 1024;
	epo *= `pagesize / 1024;
	api *= `pagesize / 1024;
	apo *= `pagesize / 1024;
	fpi *= `pagesize / 1024;
	fpo *= `pagesize / 1024;

	/* print line */
	printf("%6d %5d %5d %4d %4d %4d %4d %4d %4d %4d %6d\n",
	    re, maj, mf, fr, epi, epo, api, apo, fpi, fpo, sy);

	/* clear counters */
	epi = 0; epo = 0; api = 0; apo = 0; fpi = 0; fpo = 0;
	re = 0; mf = 0; maj = 0; fr = 0; sy = 0;
 }
'

### Run DTrace
if [ $opt_command -eq 1 ]; then
        /usr/sbin/dtrace -n "$dtrace" -x evaltime=exec -c "$command" >&2
else
        /usr/sbin/dtrace -n "$dtrace" >&2
fi

##############################################################
#!/usr/bin/sh
#
# topsyscall - display top system call type.
#              Written using DTrace (Solaris 10 3/05).
#
# This program continually prints a report of the top system calls,
# and refreshes the display every 1 second or as specified at the
# command line.
#
# 13-Jun-2005, ver 0.80
#
# USAGE:        topsyscall [interval]
#
# FIELDS:
#
#    load avg   load averages, see uptime(1)
#    syscalls   total number of syscalls in this interval
#    SYSCALL    system call name
#    COUNT      number of occurances in this interval
#
# SEE ALSO:     prstat(1M)
#
# INSPIRATION:  top(1) by William LeFebvre
#
# Standard Disclaimer: This is freeware, use at your own risk.
#
# 13-Jun-2005  Brendan Gregg   Created this.
#

#
#  Check options
#
if [ "$1" = "-h" -o "$1" = "--help" ]; then
	cat <<-END
	USAGE: topsyscall [interval]
	   eg,
	       topsyscall            # default, 1 second updates
	       topsyscall 5          # 5 second updates
	END
	exit 1
fi
interval=1
if [ "$1" -gt 0 ]; then
	interval=$1
fi

#
#  Run DTrace
#
/usr/sbin/dtrace -n '
 #pragma D option quiet
 #pragma D option destructive

 /* constants */
 inline int INTERVAL = '$interval';
 inline int SCREEN   = 20;

 /* variables */
 dtrace:::BEGIN
 {
	secs = 0;
	printf("Sampling... Please wait.\n");
 }

 /* record syscall event */
 syscall:::entry
 {
	@Name[probefunc] = count();
	@Total = count();
 }

 /* update screen */
 profile:::tick-1sec
 /++secs >= INTERVAL/
 {
        /* fetch load averages */
        this->load1a  = `hp_avenrun[0] / 65536;
        this->load5a  = `hp_avenrun[1] / 65536;
        this->load15a = `hp_avenrun[2] / 65536;
        this->load1b  = ((`hp_avenrun[0] % 65536) * 100) / 65536;
        this->load5b  = ((`hp_avenrun[1] % 65536) * 100) / 65536;
        this->load15b = ((`hp_avenrun[2] % 65536) * 100) / 65536;

	/* clear screen */
	system("clear");

        /* print load average */
        printf("%Y, load average: %d.%02d, %d.%02d, %d.%02d",
            walltimestamp, this->load1a, this->load1b, this->load5a,
            this->load5b, this->load15a, this->load15b);

	/* print syscall count */
	printa("   syscalls: %@d\n",@Total);

	/* print report */
	trunc(@Name, SCREEN);
	printf("\n   %-25s %12s\n", "SYSCALL", "COUNT");
	printa("   %-25s %@12d\n", @Name);

	/* reset variables */
	trunc(@Name);
	clear(@Total);
	secs = 0;
 }
'

##############################################################
#!/usr/bin/sh
#
# shellsnoop - A program to print read/write details from shells,
#	       such as keystrokes and command outputs.
#	       Written using DTrace (Solaris 10 3/05).
#
# This program sounds somewhat dangerous (snooping keystrokes), but is
# no more so than /usr/bin/truss, and both need root or dtrace privileges to
# run. In fact, less dangerous, as we only print visible text (not password
# text, for example). Having said that, it goes without saying that this
# program shouldn't be used for breeching privacy of other users.
#
# 30-Nov-2005, ver 0.92  	(check for newer versions)
#
# USAGE:	shellsnoop [-hqsv] [-p PID] [-u UID]
#
#		-s		# include start time, us
#		-q		# quiet, only print data
#		-v		# include start time, string
#		-p PID		# process ID to snoop
#		-u UID		# user ID to snoop
#  eg,
#		shellsnoop		# default output
#		shellsnoop -v		# human readable timestamps
#		shellsnoop -p 1892	# snoop this PID only
#		shellsnoop -qp 1892	# watch this PID data only
#
# FIELDS:
#		UID		User ID
#		PID		process ID
#		PPID		parent process ID
#		COMM		command name
#		DIR		direction (R read, W write)
#		TEXT		text contained in the read/write
#		TIME		timestamp for the command, us
#		STRTIME		timestamp for the command, string
#
# SEE ALSO: ttywatcher
#
# CDDL HEADER START
#
#  The contents of this file are subject to the terms of the
#  Common Development and Distribution License, Version 1.0 only
#  (the "License").  You may not use this file except in compliance
#  with the License.
#
#  You can obtain a copy of the license at Docs/cddl1.txt
#  or http://www.opensolaris.org/os/licensing.
#  See the License for the specific language governing permissions
#  and limitations under the License.
#
# CDDL HEADER END
#
# Author: Brendan Gregg  [Sydney, Australia]
#
# 28-Mar-2004	Brendan Gregg	Created this.
# 21-Jan-2005	   "	  "	Wrapped in sh to provide options.
# 30-Nov-2005	   "	  "	Fixed trailing buffer text bug.
# 30-Nov-2005	   "	  "	Fixed sh no keystroke text in quiet bug.
#


##############################
# --- Process Arguments ---
#
opt_pid=0; opt_uid=0; opt_time=0; opt_timestr=0; opt_quiet=0; opt_debug=0
filter=0; pid=0; uid=0

while getopts dhp:qsu:v name
do
	case $name in
	d)	opt_debug=1 ;;
	p)	opt_pid=1; pid=$OPTARG ;;
	q)	opt_quiet=1 ;;
	s)	opt_time=1 ;;
	u)	opt_uid=1; uid=$OPTARG ;;
	v)	opt_timestr=1 ;;
	h|?)	cat <<-END >&2
		USAGE: shellsnoop [-hqsv] [-p PID] [-u UID]
		       shellsnoop		# default output
		                -q		# quiet, only print data
		                -s		# include start time, us
		                -v		# include start time, string
		                -p PID		# process ID to snoop
		                -u UID		# user ID to snoop
		END
		exit 1
	esac
done

if [ $opt_quiet -eq 1 ]; then
	opt_time=0; opt_timestr=0
fi
if [ $opt_pid -eq 1 -o $opt_uid -eq 1 ]; then
	filter=1
fi


#################################
# --- Main Program, DTrace ---
#
dtrace -n '
 /*
  * Command line arguments
  */
 inline int OPT_debug 	= '$opt_debug';
 inline int OPT_quiet 	= '$opt_quiet';
 inline int OPT_pid 	= '$opt_pid';
 inline int OPT_uid 	= '$opt_uid';
 inline int OPT_time 	= '$opt_time';
 inline int OPT_timestr	= '$opt_timestr';
 inline int FILTER 	= '$filter';
 inline int PID 	= '$pid';
 inline int UID 	= '$uid';

 #pragma D option quiet
 #pragma D option switchrate=20hz

 /*
  * Print header
  */
 dtrace:::BEGIN /OPT_time == 1/
 {
 	printf("%-14s ","TIME");
 }
 dtrace:::BEGIN /OPT_timestr == 1/
 {
 	printf("%-20s ","STRTIME");
 }
 dtrace:::BEGIN /OPT_quiet == 0/
 {
	printf("%5s %5s %8s %3s  %s\n", "PID", "PPID", "CMD", "DIR", "TEXT");
 }

 /*
  * Remember this PID is a shell child
  */
 syscall::exec:entry, syscall::exece:entry
 /execname == "sh"   || execname == "ksh"  || execname == "csh"  ||
  execname == "tcsh" || execname == "zsh"  || execname == "bash"/
 {
	child[pid] = 1;

	/* debug */
	this->parent = (char *)curthread->t_procp->p_parent->p_user.u_comm;
	OPT_debug == 1 ? printf("PID %d CMD %s started. (%s)\n",
	    pid, execname, stringof(this->parent)) : 1;
 }
 syscall::exec:entry, syscall::exece:entry
 /(OPT_pid == 1 && PID != ppid) || (OPT_uid == 1 && UID != uid)/
 {
	/* forget if filtered */
	child[pid] = 0;
 }

 /*
  * Print shell keystrokes
  */
 syscall::write:entry, syscall::read:entry
 /(execname == "sh"   || execname == "ksh"  || execname == "csh"  ||
  execname == "tcsh" || execname == "zsh"  || execname == "bash")
  && (arg0 >= 0 && arg0 <= 2)/
 {
	self->buf = arg1;
 }
 syscall::write:entry, syscall::read:entry
 /(OPT_pid == 1 && PID != pid) || (OPT_uid == 1 && UID != uid)/
 {
	self->buf = 0;
 }
 syscall::write:return, syscall::read:return
 /self->buf && child[pid] == 0 && OPT_time == 1/
 {
 	printf("%-14d ", timestamp/1000);
 }
 syscall::write:return, syscall::read:return
 /self->buf && child[pid] == 0 && OPT_timestr == 1/
 {
	printf("%-20Y ", walltimestamp);
 }
 syscall::write:return, syscall::read:return
 /self->buf && child[pid] == 0 && OPT_quiet == 0/
 {
	this->text = (char *)copyin(self->buf, arg0);
	this->text[arg0] = '\'\\0\'';

	printf("%5d %5d %8s %3s  %s\n", pid, curpsinfo->pr_ppid, execname,
	    probefunc == "read" ? "R" : "W", stringof(this->text));
 }
 syscall::write:return
 /self->buf && child[pid] == 0 && OPT_quiet == 1/
 {
	this->text = (char *)copyin(self->buf, arg0);
	this->text[arg0] = '\'\\0\'';
	printf("%s", stringof(this->text));
 }
 syscall::read:return
 /self->buf && execname == "sh" && child[pid] == 0 && OPT_quiet == 1/
 {
	this->text = (char *)copyin(self->buf, arg0);
	this->text[arg0] = '\'\\0\'';
	printf("%s", stringof(this->text));
 }
 syscall::write:return, syscall::read:return
 /self->buf && child[pid] == 0/
 {
	self->buf = 0;
 }

 /*
  * Print command output
  */
 syscall::write:entry, syscall::read:entry
 /child[pid] == 1 && (arg0 == 1 || arg0 == 2)/
 {
	self->buf = arg1;
 }
 syscall::write:return, syscall::read:return
 /self->buf && OPT_time == 1/
 {
 	printf("%-14d ", timestamp/1000);
 }
 syscall::write:return, syscall::read:return
 /self->buf && OPT_timestr == 1/
 {
	printf("%-20Y ", walltimestamp);
 }
 syscall::write:return, syscall::read:return
 /self->buf && OPT_quiet == 0/
 {
	this->text = (char *)copyin(self->buf, arg0);
	this->text[arg0] = '\'\\0\'';

	printf("%5d %5d %8s %3s  %s", pid, curpsinfo->pr_ppid, execname,
	    probefunc == "read" ? "R" : "W", stringof(this->text));

	/* here we check if a newline is needed */
	this->length = strlen(this->text);
	printf("%s", this->text[this->length - 1] == '\'\\n\'' ? "" : "\n");
	self->buf = 0;
 }
 syscall::write:return, syscall::read:return
 /self->buf && OPT_quiet == 1/
 {
	this->text = (char *)copyin(self->buf, arg0);
	this->text[arg0] = '\'\\0\'';
	printf("%s", stringof(this->text));
	self->buf = 0;
 }

 /*
  *  Cleanup
  */
 fbt:genunix:exit:entry
 {
	child[pid] = 0;

	/* debug */
	this->parent = (char *)curthread->t_procp->p_parent->p_user.u_comm;
	OPT_debug == 1 ? printf("PID %d CMD %s exited. (%s)\n",
	 pid, execname, stringof(this->parent)) : 1;
 }
'

##############################################################
#!/usr/sbin/dtrace -qs
/*
 * kill.d - watch process signals as they are sent (eg, kill -9).
 *          Written in DTrace (Solaris 10 3/05).
 *
 * 16-Jun-2005, ver 1.00
 *
 * USAGE:       kill.d
 *
 * FIELDS:
 *              FROM     source PID
 *              COMMAND  source command name
 *              TO       destination PID
 *              SIG      destination signal ("9" for a kill -9)
 *              RESULT   result of signal (-1 is for failure)
 *
 * SEE ALSO: Chapter 25, Solaris Dynamic Tracing Guide, docs.sun.com,
 *           for a solution using proc:::signal-send.
 *
 * Standard Disclaimer: This is freeware, use at your own risk.
 *
 * 09-May-2004  Brendan Gregg   Created this.
 */

dtrace:::BEGIN
{
	/* Print header */
	printf("%5s %12s %5s %-6s %s\n","FROM","COMMAND","SIG","TO","RESULT");
}

syscall::kill:entry
{
	/* Record target PID and signal */
	self->target = arg0;
	self->signal = arg1;
}

syscall::kill:return
{
	/* Print source, target, and result */
	printf("%5d %12s %5d %-6d %d\n",
	 pid,execname,self->signal,self->target,(int)arg0);

	/* Cleanup memory */
	self->target = 0;
	self->signal = 0;
}
##############################################################
#!/usr/bin/perl
#
# errinfo - report on syscall failures and print errno error messages.
#	    Written using Perl and DTrace (Solaris 10 03/05)
#
# When system calls fail, an errno variable is set to convay a meaningful
# message to the end user - so long as the program does something with it
# (eg, "ls" printing "No such file or directory"). This program fetches
# and prints details for all syscall failures along with their message,
# whether the failing program is already printing this info or not.
#
# 30-Nov-2005, ver 0.82
#
# USAGE:	errinfo [-ch] [-p PID] [-n name]
#
#		-c		# counts - aggregate style
#		-p PID		# examine this PID only
#		-n name		# examine processes with this name only
#	eg,
#		errinfo			# default output - snoop event style
#		errinfo -n ssh		# examine "ssh" processes only
#		errinfo -cn ssh		# examine "ssh" using counts
#
# FIELDS:
#		EXEC		Program name (truncated)
#		SYSCALL		System call name
#		ERR		Value of errno
#		DESC		Description of errno message
#
# SEE ALSO:	/usr/include/sys/errno.h
#
# COPYRIGHT: Copyright (c) 2005 Brendan Gregg.
#
# CDDL HEADER START
#
#  The contents of this file are subject to the terms of the
#  Common Development and Distribution License, Version 1.0 only
#  (the "License").  You may not use this file except in compliance
#  with the License.
#
#  You can obtain a copy of the license at Docs/cddl1.txt
#  or http://www.opensolaris.org/os/licensing.
#  See the License for the specific language governing permissions
#  and limitations under the License.
#
# CDDL HEADER END
#
# Author: Brendan Gregg  [Sydney, Australia]
#
# 18-Apr-2005   Brendan Gregg   Created this.
#

use Getopt::Std;

#
#  Defaults
#
$FILTER = "";
$COUNT = 0;

#
#  Command line arguments
#
&Usage() if $ARGV[0] eq "--help";
getopts('ch:n:p:') || &Usage();
&Usage() if $opt_h;
$COUNT = 1 if $opt_c;
$FILTER = "&& execname == \"$opt_n\"" if defined $opt_n;
$FILTER = "&& pid == $opt_p" if defined $opt_p;

#
#  Load errno descriptions
#
open(ERRNO,"/usr/include/sys/errno.h") || die "ERROR1: reading errno.h: $!\n";
while (chomp($line = <ERRNO>)) {
	next unless $line =~ /^#define/;
	($errno,$desc) = $line =~ /^#define\s+\S+\s+(\d+)\s+\/\*(.*)\*\//;
	$Errno{$errno} = $desc;
}
close ERRNO;

#
#  Declare DTrace script
#
 if ($COUNT) {		# aggregate style
$dtrace = <<END;
/usr/sbin/dtrace -n '
	#pragma D option quiet
	syscall:::return
	/errno != 0 && pid != \$pid $FILTER/
	{
		\@Errs[execname, probefunc, errno] = count();
	}
	dtrace:::END {
		printa("%s %s %d %\@d\\n", \@Errs);
	}'
END
 } else {		# snoop style
$dtrace = <<END;
/usr/sbin/dtrace -n '
	#pragma D option quiet
	#pragma D option switchrate=5hz
	syscall:::return
	/errno != 0 && pid != \$pid $FILTER/
	{
		printf("%s %s %d\\n", execname, probefunc, errno);
	}'
END
 }

#
#  Cleanup on signals
#
$SIG{INT} = \&Cleanup_Signal;    # Ctrl-C
$SIG{QUIT} = \&Cleanup_Signal;   # Ctrl-\
$SIG{TERM} = \&Cleanup_Signal;   # TERM

#
#  Run DTrace, process output
#

if ($COUNT) {
	print STDERR "Sampling... Hit Ctrl-C to end.\n";
	$header = 1;
} else {
	printf("%16s %16s %4s  %s\n","EXEC","SYSCALL","ERR","DESC");
}

### Open DTrace
open(DTRACE,"$dtrace |") || die "ERROR2: Can't start dtrace (perms?): $!\n";

### Process DTrace output
while (chomp($line = <DTRACE>)) {

	### Print count header
	if ($COUNT && $header) {
		printf("\n%16s %16s %4s %6s  %s\n",
		 "EXEC","SYSCALL","ERR","COUNT","DESC");
		$header = 0;
	}

	### Split data
	($execname,$syscall,$errno,$counts) = split(' ',$line);
	next if $errno eq "";

	### Fetch errno description
	$desc = $Errno{$errno};

	### Print output line
	if ($COUNT) {
		printf("%16s %16s %4d %6d %s\n",
		 $execname,$syscall,$errno,$counts,$desc);
	} else {
		printf("%16s %16s %4d %s\n",$execname,$syscall,$errno,$desc);
	}
}
close(DTRACE);

#
#  Triggered by signals
#
sub Cleanup_Signal {
}

#
#  Usage message
#
sub Usage {
        print STDERR "USAGE: errinfo [-ch] [-p PID] [-n name]\n";
	print STDERR <<ENDUSAGE;
     eg,
       errinfo       # default output - snoop event style
          -c         # counts - aggregate style
          -p 871     # examine PID 871 only
          -n ssh     # examine processes with the name "ssh" only
          -cn ssh    # examine "ssh" using counts
ENDUSAGE
        exit(1);
}

##############################################################
#!/usr/sbin/dtrace -s
/*
 * sshkeysnoop.d - A program to print keystroke details from ssh.
 *                 Written in DTrace (Solaris 10 build 63).
 *
 * WARNING: This is a demonstration program, please do not use this for
 * illegal purposes in your country such as breeching privacy.
 *
 * 16-Jun-2005, ver 0.80.       (check for newer versions)
 *
 * USAGE:       ./sshkeysnoop.d
 *
 *
 * FIELDS:
 *              UID     user ID
 *              PID     process ID
 *              PPID    parent process ID
 *              TYPE    either key (keystroke) or cmd (command)
 *              TEXT    text contained in the read/write
 *
 * Standard Disclaimer: This is freeware, use at your own risk.
 *
 * 14-Jan-2005  Brendan Gregg   Created this.
 */

#pragma D option quiet

/*
 * Print header
 */
dtrace:::BEGIN
{
        /* print header */
        printf("%5s %5s %5s %5s  %s\n","UID","PID","PPID","TYPE","TEXT");
}

/*
 * Print ssh execution
 */
syscall::exec:return, syscall::exece:return
/execname == "ssh"/
{
	/* print output line */
        printf("%5d %5d %5d %5s  %s\n\n", curpsinfo->pr_euid, pid,
	    curpsinfo->pr_ppid, "cmd", stringof(curpsinfo->pr_psargs));
}

/*
 * Determine which fd is /dev/tty
 */
syscall::open:entry, syscall::open64:entry
/execname == "ssh" && copyinstr(arg0) == "/dev/tty"/
{
	/* track this syscall */
	self->ok = 1;
}

syscall::open:return, syscall::open64:return
/self->ok/
{
	/* save fd number */
	self->fd = arg0;
}

/*
 * Print ssh keystrokes
 */
syscall::read:entry
/execname == "ssh" && arg0 == self->fd/
{
	/* remember buffer address */
        self->buf = arg1;
}

syscall::read:return
/self->buf != NULL && arg0 < 2/
{
        this->text = (char *)copyin(self->buf, arg0);

	/* print output line */
	printf("%5d %5d %5d %5s  %s\n", curpsinfo->pr_euid, pid,
	    curpsinfo->pr_ppid, "key", stringof(this->text));
	self->buf = NULL;
}

##############################################################
#!/usr/sbin/dtrace -qs
/*
** shortlived.d - determine time spent by short lived processes.
**                Written in DTrace (Solaris 10 3/05).
**
** 23-Apr-2005, ver 0.91
**
** USAGE:    shortlived.d	# wait, then hit Ctrl-C
**
** Applications that run many short lived processes can cause load
**  on the system that is difficult to identify - the processes
**  aren't sampled in time by programs such as prstat. This program
**  illustrates how much time was spent processing those extra
**  processes, and a table of process name by total times for each.
**
** SEE ALSO: execsnoop
**
** Notes: The measurements are minimum values, not all of the overheads
**  caused by process generation and destruction are measured (DTrace
**  can do so, but the script would become seriously complex).
** The summary values are accurate, the by program and by PPID values
**  are usually slightly smaller due to rounding errors.
**
** Standard Disclaimer: This is freeware, use at your own risk.
**
** 22-Apr-2005  Brendan Gregg   Created this.
*/


dtrace:::BEGIN
{
	/* save start time */
	start = timestamp;
	/* this is time spent on shortlived processes */
	procs = 0;
	/* print header */
	printf("Sampling.. Hit Ctrl-C to stop.\n");
}

/*
 * Measure parent fork time
 */
syscall::*fork*:entry
{
	/* save start of fork */
	self->fork = vtimestamp;
}
syscall::*fork*:return
/arg0 != 0 && self->fork/
{
	/* record elapsed time for the fork syscall */
	this->elapsed = vtimestamp - self->fork;
	procs += this->elapsed;
	self->fork = 0;
}

/*
 * Measure child processes time
 */
syscall::*fork*:return
/arg0 == 0/
{
	/* save start of child process */
	self->start = vtimestamp;
	/* memory cleanup */
	self->fork = 0;
}
proc:::exit
/self->start/
{
	/* record elapsed time for process execution */
	this->elapsed = vtimestamp - self->start;
	procs += this->elapsed;
	/* sum elapsed by process name and ppid */
	@Times_exec[execname] = sum(this->elapsed/1000000);
	@Times_ppid[ppid] = sum(this->elapsed/1000000);
	/* memory cleanup */
	self->start = 0;
}

dtrace:::END
{
	/* print report */
	this->total = timestamp - start;
	printf("short lived processes: %6d.%03d secs\n",
	 procs/1000000000,(procs%1000000000)/1000000);
	printf("total sample duration: %6d.%03d secs\n",
	 this->total/1000000000,(this->total%1000000000)/1000000);
	printf("\nTotal time by process name,\n");
	printa("%18s %@12d ms\n",@Times_exec);
	printf("\nTotal time by PPID,\n");
	printa("%18d %@12d ms\n",@Times_ppid);
}

##############################################################
#!/usr/bin/sh
#
# cputimes - print CPU time consumed by Kernel/Idle/Processes.
#            Written using DTrace (Solaris 10 3/05).
#
# 22-Sep-2005, ver 0.73         (check for newer versions)
#
# This program accurately measures time consumed by the kernel, but in
# doing so creates extra kernel load of it's own. The extra kernel
# activity can be measured by running one cputimes and then another, and
# comparing the difference in kernel consumed time. This method can be
# used to estimate the load created by other DTrace scripts.
#
# USAGE:	cputimes [-ahTV] [-t top] [interval [count]]
#
#		-a                # print all processes
#		-T                # print totals
#		-V                # don't print timestamps
#		-t num            # print top num lines only
#  eg,
#		cputimes 1        # print every 1 second
#		cputimes -a 10    # print all processes every 10 secs
#		cputimes -at 8 5  # print top 8 lines every 5 secs
#
#
# FIELDS:
#		THREADS         The following or the process name,
#		IDLE            Idle time - CPU running idle thread
#		KERNEL          Kernel time - Kernel servicing interrupts, ...
#		PROCESS         Process time - PIDs running on the system
#		TIME (ns)       Sum of the CPU time, ns (nanoseconds)
#
# NOTES:
# * This takes into account multiple CPU servers, the total
# seconds consumed will be a multiple of the CPU count and interval.
#
# SEE ALSO: cpudists
#           Heisenberg's uncertainty principle.
#
# COPYRIGHT: Copyright (c) 2005 Brendan Gregg.
#
# CDDL HEADER START
#
#  The contents of this file are subject to the terms of the
#  Common Development and Distribution License, Version 1.0 only
#  (the "License").  You may not use this file except in compliance
#  with the License.
#
#  You can obtain a copy of the license at Docs/cddl1.txt
#  or http://www.opensolaris.org/os/licensing.
#  See the License for the specific language governing permissions
#  and limitations under the License.
#
# CDDL HEADER END
#
# Author: Brendan Gregg  [Sydney, Australia]
#
# 27-Apr-2005   Brendan Gregg   Created this.
# 22-Sep-2005      "      "	Fixed a key corruption bug.
#


##############################
# --- Process Arguments ---
#
opt_all=0; opt_time=1; opt_top=0; opt_totals=0
top=0; interval=1; count=1

while getopts aht:TV name
do
        case $name in
        a)      opt_all=1 ;;
        T)      opt_totals=1 ;;
        V)      opt_time=0 ;;
        t)      opt_top=1; top=$OPTARG ;;
        h|?)    cat <<-END >&2
		USAGE: cputimes [-ahTV] [-t top] [interval [count]]
		       cputimes                  # default output
		               -a                # print all processes
		               -T                # print totals
		               -V                # don't print times
		               -t num            # print top num lines only
		          eg,
		               cputimes 1        # print every 1 second
		               cputimes -a 10    # all processes per 10 sec
		               cputimes -at 8 5  # top 8 lines every 5 secs
		END
		exit 1
        esac
done
shift `expr $OPTIND - 1`

if [ "$1" -gt 0 ]; then
        interval=$1; count=-1; shift
fi
if [ "$1" -gt 0 ]; then
	count=$1; shift
fi


#################################
# --- Main Program, DTrace ---
#
/usr/sbin/dtrace -n '
 #pragma D option quiet

 /*
  * Command line arguments
  */
 inline int OPT_all    = '$opt_all';
 inline int OPT_time   = '$opt_time';
 inline int OPT_totals = '$opt_totals';
 inline int OPT_top    = '$opt_top';
 inline int TOP        = '$top';
 inline int INTERVAL   = '$interval';
 inline int COUNTER    = '$count';

 /* Initialise variables */
 dtrace:::BEGIN
 {
	cpustart[cpu] = 0;
	counts = COUNTER;
	secs = INTERVAL;
 }

 /* Flag this thread as idle */
 sysinfo:unix:idle_enter:idlethread
 {
	idle[cpu] = 1;
 }

 /* Save kernel time between running threads */
 sched:::on-cpu
 /cpustart[cpu]/
 {
	this->elapsed = timestamp - cpustart[cpu];
	@Procs["KERNEL"] = sum(this->elapsed);
 }

 /* Save the elapsed time of a thread */
 sched:::off-cpu,
 sched:::remain-cpu,
 profile:::profile-1sec
 /cpustart[cpu]/
 {
	/* determine the name for this thread */
	program[cpu] = pid == 0 ? idle[cpu] ? "IDLE" : "KERNEL" :
	    OPT_all ? execname : "PROCESS";

	/* save elapsed */
	this->elapsed = timestamp - cpustart[cpu];
	@Procs[program[cpu]] = sum(this->elapsed);
	cpustart[cpu] = timestamp;
 }

 /* Record the start time of a thread */
 sched:::on-cpu,
 sched:::remain-cpu
 {
	idle[cpu] = 0;
	cpustart[cpu] = timestamp;
 }


 profile:::tick-1sec
 {
	secs--;
 }

 /* Print time */
 profile:::tick-1sec
 /secs == 0/
 {
	OPT_time ? printf("%Y,\n", walltimestamp) : 1;
	printf("%16s %16s\n", "THREADS", "TIME (ns)");
 }

 /* Print report */
 profile:::tick-1sec
 /secs == 0/
 {
	OPT_top ? trunc(@Procs, TOP) : 1;
	printa("%16s %@16d\n", @Procs);
	trunc(@Procs);
	secs = INTERVAL;
	counts--;
 }

 /* End of program */
 profile:::tick-1sec
 /counts == 0/
 {
	exit(0);
 }

 /* cleanup for Ctrl-C */
 dtrace:::END
 {
	trunc(@Procs);
 }
'

##############################################################
#!/usr/bin/sh
#
# cpudists - print CPU time distributions by Kernel/Idle/Processes.
#            Written using DTrace (Solaris 10 3/05).
#
# 22-Sep-2005, ver 0.73         (check for newer versions)
#
# USAGE:	cpudists [-ahV] [-t top] [interval [count]]
#
#		-a              # print all processes
#		-V              # don't print timestamps
#		-t num          # print top num  only
#  eg,
#		cpudists 1      # print every 1 second
#		cpudists -a 10  # print all processes every 10 secs
#
#
# FIELDS:
#		value           The following or the process name,
#		IDLE            Idle time - CPU running idle thread
#		KERNEL          Kernel time - Kernel servicing interrupts, ...
#		PROCESS         Process time - PIDs running on the system
#		count           Number of occurances at least this duration (ns)
#
# NOTES:
# * This takes into account multiple CPU servers, the total
# seconds consumed will be a multiple of the CPU count and interval.
#
# SEE ALSO: cputimes
#
# COPYRIGHT: Copyright (c) 2005 Brendan Gregg.
#
# CDDL HEADER START
#
#  The contents of this file are subject to the terms of the
#  Common Development and Distribution License, Version 1.0 only
#  (the "License").  You may not use this file except in compliance
#  with the License.
#
#  You can obtain a copy of the license at Docs/cddl1.txt
#  or http://www.opensolaris.org/os/licensing.
#  See the License for the specific language governing permissions
#  and limitations under the License.
#
# CDDL HEADER END
#
# Author: Brendan Gregg  [Sydney, Australia]
#
# 27-Apr-2005   Brendan Gregg   Created this.
# 22-Sep-2005	   "      "	Fixed key corruption bug.
#


##############################
# --- Process Arguments ---
#
opt_all=0; opt_time=1; opt_top=0; top=0; interval=1; count=1

while getopts aht:V name
do
        case $name in
        a)      opt_all=1 ;;
        V)      opt_time=0 ;;
        t)      opt_top=1; top=$OPTARG ;;
        h|?)    cat <<-END >&2
		USAGE: cpudists [-ahV] [-t top] [interval [count]]
		       cpudists                # default output
		               -a              # print all processes
		               -V              # don't print times
		               -t num          # print top num only
		END
		exit 1
        esac
done
shift `expr $OPTIND - 1`

if [ "$1" -gt 0 ]; then
        interval=$1; count=-1; shift
fi
if [ "$1" -gt 0 ]; then
	count=$1; shift
fi


#################################
# --- Main Program, DTrace ---
#
/usr/sbin/dtrace -n '
 #pragma D option quiet

 /*
  * Command line arguments
  */
 inline int OPT_all    = '$opt_all';
 inline int OPT_time   = '$opt_time';
 inline int OPT_top    = '$opt_top';
 inline int TOP        = '$top';
 inline int INTERVAL   = '$interval';
 inline int COUNTER    = '$count';

 /* Initialise variables */
 dtrace:::BEGIN
 {
	cpustart[cpu] = 0;
	counts = COUNTER;
	secs = INTERVAL;
 }

 /* Flag this thread as idle */
 sysinfo:unix:idle_enter:idlethread
 {
	idle[cpu] = 1;
 }

 /* Save kernel time between running threads */
 sched:::on-cpu
 /cpustart[cpu]/
 {
	this->elapsed = timestamp - cpustart[cpu];
	@Procs["KERNEL"] = quantize(this->elapsed);
 }

 /* Save the elapsed time of a thread */
 sched:::off-cpu,
 sched:::remain-cpu,
 profile:::profile-1sec
 /cpustart[cpu]/
 {
	/* determine the name for this thread */
	program[cpu] = pid == 0 ? idle[cpu] ? "IDLE" : "KERNEL" :
	    OPT_all ? execname : "PROCESS";

	/* save elapsed */
	this->elapsed = timestamp - cpustart[cpu];
	@Procs[program[cpu]] = quantize(this->elapsed);
	cpustart[cpu] = timestamp;
 }

 /* Record the start time of a thread */
 sched:::on-cpu,
 sched:::remain-cpu
 {
	idle[cpu] = 0;
	cpustart[cpu] = timestamp;
 }

 profile:::tick-1sec
 {
	secs--;
 }

 /* Print time */
 profile:::tick-1sec
 /secs == 0 && OPT_time/
 {
	printf("%Y,\n", walltimestamp);
 }

 /* Print report */
 profile:::tick-1sec
 /secs == 0/
 {
	OPT_top ? trunc(@Procs, TOP) : 1;
	printa("%16s %@16d\n", @Procs);
	trunc(@Procs);
	secs = INTERVAL;
	counts--;
 }

 /* End of program */
 profile:::tick-1sec
 /counts == 0/
 {
	exit(0);
 }

 /* cleanup for Ctrl-C */
 dtrace:::END
 {
	trunc(@Procs);
 }
'

##############################################################
#!/usr/sbin/dtrace -s
/*
 * setuids.d - snoop setuid calls. This can examine user logins.
 *             Written in DTrace (Solaris 10 3/05).
 *
 * 18-Jun-2005, ver 1.00
 *
 *
 * USAGE:	./setuids.d
 *
 * FIELDS:
 *		UID	user ID (from)
 *		SUID	set user ID (to)
 *		PPID	parent process ID
 *		PID	process ID
 *		PCMD	parent command
 *		CMD	command (full arguments)
 *
 * SEE ALSO: BSM auditing
 *
 * Standard Disclaimer: This is freeware, use at your own risk.
 *
 * 09-May-2004	Brendan Gregg	Created this.
 * 08-May-2005	   "      " 	Used modern variable builtins.
 */

#pragma D option quiet

/*
 * Print header
 */
dtrace:::BEGIN
{
	printf("%5s %5s %5s %5s %-12s %s\n",
	    "UID", "SUID", "PPID", "PID", "PCMD", "CMD");
}

/*
 * Save values
 */
syscall::setuid:entry
{
	self->uid = uid;
	self->suid = arg0;
	self->ok = 1;
}

/*
 * Print output on success
 */
syscall::setuid:return
/arg0 == 0 && self->ok/
{
	printf("%5d %5d %5d %5d %-12s %s\n",
	    self->uid, self->suid, ppid, pid,
	    stringof(curthread->t_procp->p_parent->p_user.u_comm),
	    stringof(curpsinfo->pr_psargs));
}

/*
 * Cleanup
 */
syscall::setuid:return
{
	self->uid = 0;
	self->suid = 0;
	self->ok = 0;
}

##############################################################
#!/usr/sbin/dtrace -s
/*
 * bitesize.d - analyse disk I/O size by process.
 *              Written using DTrace (Solaris 10 build 63).
 *
 * This produces a report for the size of disk events caused by
 * processes. These are the disk events sent by the block I/O driver.
 *
 * If applications must use the disks, we generally prefer they do so
 * sequentially with large I/O sizes.
 *
 * 15-Jun-2005, ver 1.00
 *
 * USAGE:	bitesize.d	# wait several seconds, then hit Ctrl-C
 *
 * FIELDS:
 *		PID	process ID
 *		CMD	command and argument list
 *		value	size in bytes
 *		count	number of I/O operations
 *
 * NOTES:
 * The application may be requesting smaller sized operations, which
 * are being rounded up to the nearest sector size or UFS block size.
 * To analyse what the application is requesting, DTraceToolkit programs
 * such as Proc/fddist may help.
 *
 * SEE ALSO: seeksize.d, iosnoop
 *
 * Standard Disclaimer: This is freeware, use at your own risk.
 *
 * 31-Mar-2004	Brendan Gregg	Created this, build 51.
 * 10-Oct-2004	   "      "	Rewrote to use the io provider, build 63.
 */

#pragma D option quiet

/*
 * Print header
 */
dtrace:::BEGIN
{
	printf("Sampling... Hit Ctrl-C to end.\n");
}

/*
 * Process io start
 */
io:::start
{
	/* fetch details */
	this->size = args[0]->b_bcount;
	cmd = (string)curpsinfo->pr_psargs;

	/* store details */
	@Size[pid,cmd] = quantize(this->size);
}

/*
 * Print final report
 */
dtrace:::END
{
	printf("\n%8s  %s\n","PID","CMD");
	printa("%8d  %s\n%@d\n",@Size);
}
##############################################################
#!/usr/sbin/dtrace -s
/*
 * seeksize.d - analyse disk head seek distance by process.
 *              Written using DTrace (Solaris 10 3/05).
 *
 * Disk I/O events caused by processes will in turn cause the disk heads
 * to seek. This program analyses those seeks, so that we can determine
 * if processes are causing the disks to seek in a "random" or "sequential"
 * manner.
 *
 * 15-Jun-2005, ver 1.00
 *
 * USAGE:	seeksize.d		# wait several seconds, then hit Ctrl-C
 *
 * FIELDS:
 *		PID	process ID
 *		CMD	command and argument list
 *		value	distance in disk blocks (sectors)
 *		count	number of I/O operations
 *
 * SEE ALSO: bitesize.d, iosnoop
 *
 * Standard Disclaimer: This is freeware, use at your own risk.
 *
 * 11-Sep-2004	Brendan Gregg	Created this.
 * 10-Oct-2004	   "      "	Rewrote to use the io provider.
 */

#pragma D option quiet

/*
 * Print header
 */
dtrace:::BEGIN
{
	printf("Sampling... Hit Ctrl-C to end.\n");
}

self int last[dev_t];

/*
 * Process io start
 */
io:::start
{
	/* fetch details */
	this->dev = args[0]->b_edev;
	this->blk = args[0]->b_blkno;
	this->size = args[0]->b_bcount;
	cmd = (string)curpsinfo->pr_psargs;
}
io:::start
/self->last[this->dev] != 0/
{
	/* calculate seek distance */
	this->dist = this->blk - self->last[this->dev] > 0 ?
	    this->blk - self->last[this->dev] :
	    self->last[this->dev] - this->blk;

	/* store details */
	@Size[pid,cmd] = quantize(this->dist);
}
io:::start
{
	/* save last position of disk head */
	self->last[this->dev] = this->blk + this->size / 512;
}

/*
 * Print final report
 */
dtrace:::END
{
	printf("\n%8s  %s\n","PID","CMD");
	printa("%8d  %s\n%@d\n",@Size);
}
##############################################################
#!/usr/bin/ksh
#
# zvmstat - print vmstat style info per Zone.
#           This uses DTrace (Solaris 10 3/05).
#
# This program must be run from the global zone as root.
#
# 08-Jan-2006, ver 0.63         (check for newer versions)
#
# USAGE: 	zvmstat [-ht] [interval [count]]
#
#		zvmstat         # default output
#			-t      # print times
#  eg,
#		zvmstat 1       # print every 1 second
#		zvmstat 10 5    # print 5 x 10 second samples
#		zvmstat -t 5    # print every 5 seconds with time
#
#
# FIELDS:
#		re		page reclaims
#		mf		minor faults
#		fr		pages freed
#		sr		scan rate
#		epi		executable pages paged in
#		epo		executable pages paged out
#		epf		executable pages freed
#		api		anonymous pages paged in
#		apo		anonymous pages paged out
#		apf		anonymous pages freed
#		fpi		filesystem pages paged in
#		fpo		filesystem pages paged out
#		fpf		filesystem pages freed
#
# NOTES:
# - Zone status should really be provided by Kstat, which currently
#   provides system wide values, per CPU and per processor set, but not per
#   zone. DTrace can fill this role in the meantime until Kstat supports zones.
# - First output does not contain summary since boot.
#
# SEE ALSO: prstat -Z
#
# COPYRIGHT: Copyright (c) 2005 Brendan Gregg.
#
# CDDL HEADER START
#
#  The contents of this file are subject to the terms of the
#  Common Development and Distribution License, Version 1.0 only
#  (the "License").  You may not use this file except in compliance
#  with the License.
#
#  You can obtain a copy of the license at Docs/cddl1.txt
#  or http://www.opensolaris.org/os/licensing.
#  See the License for the specific language governing permissions
#  and limitations under the License.
#
# CDDL HEADER END
#
# BUGS:
# - First output may not contain all zones due to how loops are achieved.
#   Check for newer versions.
#
# Author: Brendan Gregg  [Sydney, Australia]
#
# 11-May-2005   Brendan Gregg   Created this.
# 26-Jul-2005	   "      "	Improved code.
#


##############################
# --- Process Arguments ---
#

### default variables
opt_time=0; interval=1; counts=1

### process options
while getopts ht name
do
	case $name in
	t)      opt_time=1 ;;
	h|?)    cat <<-END >&2
		USAGE: zvmstat [-ht] [interval [count]]
		       zvmstat         # default output
		               -t      # print times
		   eg,
		       zvmstat 1       # print every 1 second
		       zvmstat 10 5    # print 5 x 10 second samples
		       zvmstat -t 5    # print every 5 seconds with time
		END
		exit 1
	esac
done
shift $(( OPTIND - 1 ))

### option logic
if (( "0$1" > 0 )); then
        interval=$1; counts=-1; shift
fi
if (( "0$1" > 0 )); then
        counts=$1; shift
fi


#################################
# --- Main Program, DTrace ---
#
dtrace -n '
 #pragma D option quiet
 #pragma D option destructive
 #pragma D option switchrate=10

 /*
  * Command line arguments
  */
 inline int OPT_time   = '$opt_time';
 inline int INTERVAL   = '$interval';
 inline int COUNTER    = '$counts';

 /*
  * Initialise variables
  */
 dtrace:::BEGIN
 {
	secs = INTERVAL;
	counts = COUNTER;
	zonemax = 0;
	listing = 1;
	re[""] = 0; pi[""] = 0; po[""] = 0;
	mf[""] = 0; sr[""] = 0; fr[""] = 0;
	epi[""] = 0; epo[""] = 0; epf[""] = 0;
	api[""] = 0; apo[""] = 0; apf[""] = 0;
	fpi[""] = 0; fpo[""] = 0; fpf[""] = 0;
 }

 /*
  * Build zonelist array
  *
  * Here we want the output of a command to be saved into an array
  * inside dtrace. This is done by running the command, sending the
  * output to /dev/null, and by probing its write syscalls from dtrace.
  *
  * This is an example of a "scraper".
  */

 /*
  * List zones
  */
 dtrace:::BEGIN
 {
	/* run zoneadm */
	system("/usr/sbin/zoneadm list > /dev/null; echo END > /dev/null");
 }

 /*
  * Scrape zone listing
  */
 syscall::write:entry
 /listing && (execname == "zoneadm") &&
 (curthread->t_procp->p_parent->p_ppid == $pid)/
 {
	/* read zoneadm output */
	zonelist[zonemax] = stringof(copyin(arg1, arg2 - 1));

	/* increment max number of zones */
	zonemax++;
 }

 /*
  * Finish scraping zones
  */
 syscall::write:entry
 /listing && (execname == "sh") && (ppid == $pid)/
 {
	/*
	 * this end tag lets us know our zonelist has finished.
	 * thanks A. Packer.
	 */
	listing = stringof(copyin(arg1, arg2 - 1)) == "END" ? 0 : 1;
 }

 /*
  * Record vminfo counters
  */
 vminfo:::pgrec      { re[zonename] += arg0; }
 vminfo:::as_fault   { mf[zonename] += arg0; }
 vminfo:::scan       { sr[zonename] += arg0; }
 vminfo:::execpgin   { epi[zonename] += arg0; }
 vminfo:::execpgout  { epo[zonename] += arg0; }
 vminfo:::execfree   { epf[zonename] += arg0; fr[zonename] += arg0; }
 vminfo:::anonpgin   { api[zonename] += arg0; }
 vminfo:::anonpgout  { apo[zonename] += arg0; }
 vminfo:::anonfree   { apf[zonename] += arg0; fr[zonename] += arg0; }
 vminfo:::fspgin     { fpi[zonename] += arg0; }
 vminfo:::fspgout    { fpo[zonename] += arg0; }
 vminfo:::fsfree     { fpf[zonename] += arg0; fr[zonename] += arg0; }

 /*
  * Timer
  */
 profile:::tick-1sec
 {
	secs--;
 }

 /*
  * Check for exit
  */
 profile:::tick-1sec
 /counts == 0/
 {
	exit(0);
 }

 /*
  * Print header line
  */
 profile:::tick-1sec
 /secs == 0/
 {
	/* set counters */
	secs = INTERVAL;
	counts--;
	zonei = 0;

	/* print time */
	OPT_time ? printf("\n%Y,\n",walltimestamp) : 1;

	/* print output line */
	printf("%10s %4s %5s %4s %5s %4s %4s %4s %4s %4s %4s %4s %4s %4s\n",
	    "ZONE", "re", "mf", "fr", "sr", "epi", "epo", "epf", "api", "apo",
	    "apf", "fpi", "fpo", "fpf");

	/* ensure zone writes are triggered */
	printf(" \b");
 }

 /*
  * Print zone status line
  *
  * This is a fairly interesting function in that it loops over the keys in
  * an associative array and prints out the values. DTrace cant really do
  * loops, and generally doesnt need to. We "cheat" by generating writes
  * in the above probe which in turn trigger the probe below which
  * contains the contents of each loop. Dont do this at home! We are
  * supposed to use aggreagations instead, wherever possible.
  *
  * This is an example of a "feedback loop".
  */
 syscall::write:return
 /pid == $pid && zonei < zonemax/
 {
	/* fetch zonename */
	self->zone = zonelist[zonei];

	/* print output */
	printf("%10s %4d %5d %4d %5d %4d %4d %4d %4d %4d %4d %4d %4d %4d\n",
	    self->zone, re[self->zone], mf[self->zone], fr[self->zone],
	    sr[self->zone], epi[self->zone], epo[self->zone],
	    epf[self->zone], api[self->zone], apo[self->zone],
	    apf[self->zone], fpi[self->zone], fpo[self->zone],
	    fpf[self->zone]);

	/* clear values */
	re[self->zone] = 0; mf[self->zone] = 0; fr[self->zone] = 0;
	sr[self->zone] = 0; epi[self->zone] = 0; epo[self->zone] = 0;
	epf[self->zone] = 0; api[self->zone] = 0; apo[self->zone] = 0;
	apf[self->zone] = 0; fpi[self->zone] = 0; fpo[self->zone] = 0;
	fpf[self->zone] = 0;
	self->zone = 0;

	/* go to next zone */
	zonei++;
 }
'

##############################################################
#!/usr/bin/ksh
#
# zhostid - demo changing hostids for Solaris Zones.
#           Written using DTrace (Solaris 10 3/05).
#
# WARNING: This is a demonstration of DTrace, it is not intended as a
# standard daemon. In particular, hostids are used by Sun to track support
# calls, so changing hostids may make life somewhat confusing for all.
#
# 21-Jun-2005, ver 0.70		(first release)
#
# USAGE:	zhostid &
#
# Edit the "Configuration" section below to set the zones and
# hostids to what is desirable.
#
# BASED ON: hostid.d by Iain Hayes, and idea by Jon Haslam.
#
# COPYRIGHT: Copyright (c) 2005 Brendan Gregg.
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#  (http://www.gnu.org/copyleft/gpl.html)
#
# 21-Jun-2005	Brendan Gregg	Created this.

#
#  Configuration
#
hostids='
		global		12345678
		workzone1	90abcdef

' # simply modify the above by adding extra lines for each zone.

#
#  Check hostids
#
print "$hostids" | while read zone hostid_hex; do
	### Sanity check hostid
	if [[ "$zone" == "" || "$zone" == "#" ]]; then continue; fi
	if [[ "$hostid_hex" == *[g-zG-Z]* ]]; then
		print "ERROR2: Invalid hostid $hostid_hex. "
		print "Please use hexadecimal.\n"
		exit 2
	fi
	if (( ${#hostid_hex} > 11 )); then
		# see /usr/src/uts/common/conf/param.c for limit.
		print "ERROR3: Length of hostid $hostid_hex too long. "
		print "Limit 11 chars.\n"
		exit 3
	fi

	### Convert hostid to decimal
	typeset -i10 hostid_dec
	hostid_dec=16#$hostid_hex

	### Build DTrace code
	body="$body
		syscall::systeminfo:return
		/zonename == \"$zone\" && self->command == 7/
		{
			copyoutstr(\"$hostid_dec\", self->buffer, 11);
		}"
done

#
#  Run DTrace
#
exec /usr/sbin/dtrace -n '

 #pragma D option destructive
 #pragma D option quiet
 #pragma D option bufsize=32k

 inline string hostid = "'$hostid_dec'";

 syscall::systeminfo:entry
 {
	self->command = arg0;
	self->buffer = arg1;
 }

 '"$body"'

 syscall::systeminfo:return
 {
	self->command = 0;
	self->buffer = 0;
 }
'

##############################################################
#!/usr/bin/ksh
#
# zhostid - demo changing hostids for Solaris Zones.
#           Written using DTrace (Solaris 10 3/05).
#
# WARNING: This is a demonstration of DTrace, it is not intended as a
# standard daemon. In particular, hostids are used by Sun to track support
# calls, so changing hostids may make life somewhat confusing for all.
#
# 21-Jun-2005, ver 0.70		(first release)
#
# USAGE:	zhostid &
#
# Edit the "Configuration" section below to set the zones and
# hostids to what is desirable.
#
# BASED ON: hostid.d by Iain Hayes, and idea by Jon Haslam.
#
# COPYRIGHT: Copyright (c) 2005 Brendan Gregg.
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#  (http://www.gnu.org/copyleft/gpl.html)
#
# 21-Jun-2005	Brendan Gregg	Created this.

#
#  Configuration
#
hostids='
		global		12345678
		workzone1	90abcdef

' # simply modify the above by adding extra lines for each zone.

#
#  Check hostids
#
print "$hostids" | while read zone hostid_hex; do
	### Sanity check hostid
	if [[ "$zone" == "" || "$zone" == "#" ]]; then continue; fi
	if [[ "$hostid_hex" == *[g-zG-Z]* ]]; then
		print "ERROR2: Invalid hostid $hostid_hex. "
		print "Please use hexadecimal.\n"
		exit 2
	fi
	if (( ${#hostid_hex} > 11 )); then
		# see /usr/src/uts/common/conf/param.c for limit.
		print "ERROR3: Length of hostid $hostid_hex too long. "
		print "Limit 11 chars.\n"
		exit 3
	fi

	### Convert hostid to decimal
	typeset -i10 hostid_dec
	hostid_dec=16#$hostid_hex

	### Build DTrace code
	body="$body
		syscall::systeminfo:return
		/zonename == \"$zone\" && self->command == 7/
		{
			copyoutstr(\"$hostid_dec\", self->buffer, 11);
		}"
done

#
#  Run DTrace
#
exec /usr/sbin/dtrace -n '

 #pragma D option destructive
 #pragma D option quiet
 #pragma D option bufsize=32k

 inline string hostid = "'$hostid_dec'";

 syscall::systeminfo:entry
 {
	self->command = arg0;
	self->buffer = arg1;
 }

 '"$body"'

 syscall::systeminfo:return
 {
	self->command = 0;
	self->buffer = 0;
 }
'
##############################################################
#!/usr/sbin/dtrace -Cs
/*
** socketsnoop.d - snoop TCP network socket traffic by process.
**              This is intended to identify the process responsible
**              for network traffic. Written in DTrace (Solaris 10 build 63).
**
** THIS SCRIPT HAS BEEN DEPRECATED in favour of the TCP scripts from
** the DTraceToolkit, http://www.opensolaris.org/os/community/dtrace.
**
** This matches most types of TCP traffic, but not all types. It is
**  useful as it shows which processes are causing at least this much
**  network activity.
**
** 12-Mar-2005, ver 0.65        (check for newer versions)
**
**
** USAGE:       ./socketsnoop.d
**
**      Different styles of output can be selected by changing
**      the "PFORMAT" variable below.
**
** FIELDS:
**              UID     user ID
**              PID     process ID
**              PPID    parent process ID
**              CMD     command (full arguments)
**              DIR     direction
**              SIZE    size of payload data
**              TIME    timestamp, us
**
** The size is the data payload size not the packet size.
**
** SEE ALSO: snoop -rS
**           sock_top.d, James Dickens
**
** Standard Disclaimer: This is freeware, use at your own risk.
**
** THANKS: James Dickens
**
** ToDo: UDP, ICMP.
**
** 09-Jul-2004  Brendan Gregg   Created this.
** 12-Mar-2005     "      "	Changed probes, size info now printed.
**
*/

#include <sys/vnode.h>
#include <sys/socket.h>

inline int PFORMAT = 1;
/*                      1 - Default output
**                      2 - Timestamp output (includes TIME)
**                      3 - Everything, space delimited (for spreadsheets)
*/

#pragma D option quiet


/*
**  Print header
*/
dtrace:::BEGIN /PFORMAT == 1/ {
        printf("%5s %5s %3s %5s %s\n","UID","PID","DIR","SIZE","CMD");
        this->readsize = 0;
}
dtrace:::BEGIN /PFORMAT == 2/ {
        printf("%-14s %5s %5s %3s %5s %s\n",
         "TIME","UID","PID","DIR","SIZE","CMD");
}
dtrace:::BEGIN /PFORMAT == 3/ {
        printf("%s %s %s %s %s %s %s\n",
         "TIME","UID","PID","PPID","DIR","SIZE","CMD");
}


/*
**  Store Write Values
*/
fbt:ip:tcp_output:entry
{
        self->dir = "W";
        self->size = msgdsize(args[1]);
	self->ok = 1;
}

/*
**  Store Read Values
*/
fbt:sockfs:sotpi_recvmsg:entry
{
        self->dir = "R";
	/* We track the read request (man uio), */
	self->uiop = (struct uio *) arg2;
	self->residual = self->uiop->uio_resid;
        /* check family */
	this->sonode = (struct sonode *)arg0;
        self->ok = (int)this->sonode->so_family == AF_INET ||
            (int)this->sonode->so_family == AF_INET6 ? 1 : 0;
        /* check type */
        self->ok = (int)this->sonode->so_type == SOCK_STREAM ? self->ok : 0;
}
fbt:sockfs:sotpi_recvmsg:return
/arg0 != 0 && self->ok/
{
	/* calculate successful read size */
	self->size = self->residual - self->uiop->uio_resid;
}

/*
**  Print output
*/
ip:tcp_output:entry, fbt:sockfs:sotpi_recvmsg:return
/PFORMAT == 1 && self->ok/
{
        printf("%5d %5d %3s %5d %s\n",
         uid,pid,self->dir,self->size,curpsinfo->pr_psargs);
}
ip:tcp_output:entry, fbt:sockfs:sotpi_recvmsg:return
/PFORMAT == 2 && self->ok/
{
        printf("%-14d %5d %5d %3s %5d %s\n",
         timestamp/1000,uid,pid,self->dir,self->size,
         curpsinfo->pr_psargs);
}
ip:tcp_output:entry, fbt:sockfs:sotpi_recvmsg:return
/PFORMAT == 3 && self->ok/
{
        printf("%d %d %d %d %s %d %s\n",
         timestamp/1000,uid,pid,ppid,self->dir,
	 self->size,curpsinfo->pr_psargs);
}

/*
**  Cleanup
*/
ip:tcp_output:entry, fbt:sockfs:sotpi_recvmsg:return
{
	self->ok = 0;
        self->dir = 0;
        self->size = 0;
        self->residual = 0;
        self->uiop = 0;
}

##############################################################
#!/usr/sbin/dtrace -s
/*
** anonprofile.d - snoop process anonymous memory reservation as it occurs.
**		 Written in DTrace (Solaris 10 x86 build 51).
**
** 18-May-2004, ver 0.60	(early release, check for newer versions)
**
**
** USAGE:	./anonprofile.d
**
**	Different styles of output can be selected by changing
**	the "PFORMAT" variable below.
**
** FIELDS:
**		UID	user ID
**		PID	process ID
**		PPID	parent process ID
**		TOTAL	total size of anon mem usage, bytes
**		SIZE	size of anon mem resv or unresv, bytes
**		ARGS	command (full arguments)
**		TIME	timestamp, us
**
** SEE ALSO: pmap
**
** NOTE: private kernel structures are read, this script may not work on
**	newer builds of Solaris 10.
**
** Standard Disclaimer: This is freeware, use at your own risk.
**
** 18-May-2004	Brendan Gregg	Created this.
**
*/

inline int PFORMAT = 1;
/*			1 - Default output
**			2 - Timestamp output (includes TIME)
**			3 - Everything, space delimited (for spreadsheets)
*/

#pragma D option quiet


/*
**  Print header
*/
dtrace:::BEGIN /PFORMAT == 1/ {
	printf("%5s %5s %9s %s\n","UID","PID","TOTAL","ARGS");
}
dtrace:::BEGIN /PFORMAT == 2/ {
	printf("%-14s %5s %5s %9s %s\n",
	 "TIME","UID","PID","TOTAL","ARGS");
}
dtrace:::BEGIN /PFORMAT == 3/ {
	printf("%s %s %s %s %s %s %s\n",
	 "TIME","UID","PID","PPID","TOTAL","SIZE","ARGS");
}


/*
**  Main
*/
fbt:genunix:anon_resvmem:entry
/arg1 != 0/
{
	/* Store values for a reservation of anon mem */
	self->size = arg0;
	self->uid = curpsinfo->pr_euid;
	self->pid = pid;
	self->ppid = curpsinfo->pr_ppid;
	self->args = (char *)curpsinfo->pr_psargs;
}

fbt:genunix:anon_resvmem:return
/total[pid] == 0 && self->args != NULL && arg1 != 0/
{
	/* Increment total anon mem if successful */
	total[self->pid] = self->size;
	self->ok = 1;
}
fbt:genunix:anon_resvmem:return
/total[pid] != 0 && self->args != NULL && arg1 != 0 && ! self->ok/
{
	/* Increment total anon mem if successful */
	total[self->pid] += self->size;
	self->ok = 1;
}

fbt:genunix:anon_unresv:entry
/total[pid] > 0/
{
	/* Decrement anon mem for unreservations */
	self->size = - arg0;
	self->uid = curpsinfo->pr_euid;
	self->pid = pid;
	self->ppid = curpsinfo->pr_ppid;
	self->args = (char *)curpsinfo->pr_psargs;
	total[pid] += self->size;
	self->ok = 1;
}


/*
**  Print output
*/
fbt:genunix:anon_resvmem:return, fbt:genunix:anon_unresv:entry
/PFORMAT == 1 && self->ok/
{
	printf("%5d %5d %9d %s\n",
	 self->uid,self->pid,total[self->pid],stringof(self->args));
}
fbt:genunix:anon_resvmem:return, fbt:genunix:anon_unresv:entry
/PFORMAT == 2 && self->ok/
{
	printf("%-14d %5d %5d %9d %s\n",
	 timestamp/1000,self->uid,self->pid,
	 total[self->pid],stringof(self->args));
}
fbt:genunix:anon_resvmem:return, fbt:genunix:anon_unresv:entry
/PFORMAT == 3 && self->ok/
{
	printf("%d %d %d %d %d %d %s\n",
	 timestamp/1000,self->uid,self->pid,self->ppid,
	 total[self->pid],self->size,stringof(self->args));
}


/*
**  Cleanup
*/
fbt:genunix:anon_resvmem:return,
fbt:genunix:anon_unresv:entry
/self->ok/
{
	self->size = 0;
	self->ok = 0;
	self->pid = 0;
	self->ppid = 0;
	self->uid = 0;
	self->args = NULL;
}
syscall::rexit:entry
{
	total[pid] = 0;
}

##############################################################
#!/usr/bin/perl
#
# intrtime - Sample and print interrput handler times.
#	 Written using DTrace (Solaris 10 x86 build 63).
#
# Time spent by the kernel servicing interrupts is not easily
#  meausrable under Unix, intrtime gives a break down of the
#  interrupt types and times spent services each.
#
# 01-Mar-2005, ver 0.84  (check for newer versions)
#
#
# USAGE: intrtime [secs]
#
#	intrtime	# default output, 1 second
#	intrtime 10	# sample for 10 seconds
#
# FIELDS:
#
#	Interrput	Interrput name
#	Time(ns)	Total time spent in this interrput (ns)
#	Time%		Percent this time is of TOTAL(dur)
#	TOTAL(int)	Total time spent in interrupts
#	TOTAL(dur)	Duration for this sample
#
# NOTE: This currently does not count the number of CPUs, so
#  Time% should really be divided by the number of CPUs handling
#  interrupts.
#
# SEE ALSO: Chapter 22, Solaris Dynamic Tracing Guide, docs.sun.com.
#           intrstat (and I wish I had discovered this sooner!)
#
# Standard Disclaimer: This is freeware, use at your own risk.
#
# Author: Brendan Gregg  [Sydney, Australia]
#
# 27-Feb-2005	Brendan Gregg	Created this.
# 01-Mar-2005	   "	  "	Now using device major names.
#


### Process Arguments
&usage() if $ARGV[0] =~ /^-/;
&usage() if $ARGV[0] =~ /^\D/;
$secs = $ARGV[0] || 1;
$| = 1;

### name_to_major to major_to_name
open(MAJOR,"/etc/name_to_major") ||
 die("ERROR1: Can't read /etc/name_to_major: $!\n");
chomp(@Lines = <MAJOR>);
close MAJOR;
foreach $line (@Lines) {
	($name,$num) = split(' ',$line);
	$Major_to_name{$num} = $name;
}


#
#  DTrace Script
#
$intr_d = '/usr/sbin/dtrace -qn \'
 /* This measures interrput thread times */
 dtrace:::BEGIN {
	self->begin = timestamp;
	secs = ' . $secs . ';
 }

 profile:::tick-1sec
 /secs > 0/
 {
	secs--;
 }
 profile:::tick-1sec
 /secs == 0/
 {
	exit(0);
 }

 sdt:::interrupt-start {
	self->start = timestamp;
 }

 sdt:::interrupt-complete {
	this->delta = timestamp - self->start;
	this->devinfo = (struct dev_info *)arg0;
	major = this->devinfo == 0 ? -1 : this->devinfo->devi_major;
	@Ints[major] = sum(this->delta);
	@Totals["TOTAL(int)"] = sum(this->delta);
	self->start = 0;
 }

 dtrace:::END {
	@Totals["TOTAL(dur)"] = sum(timestamp - self->begin);
	printa("%12d %16@d\n",@Ints);
	printa("%12s %16@d\n",@Totals);
 }\'';


#
#  Execute DTrace
#
@Lines = `$intr_d`;


#
#  Print Report
#
foreach $line (@Lines) {
	$line =~ s/^  *//;
	($major,$ns) = split(' ',$line);
	$totaldur = $ns if $major eq "TOTAL(dur)";
}

printf("%12s %16s %7s\n","Interrupt","Time(ns)","%Time");

foreach $line (@Lines) {
	next if $line =~ /^\s*$/;
	($major,$ns) = split(' ',$line);
	if ($major !~ /^\s*TOTAL/) {
		next if $major < 0 || $major > 65536;
		# translate majors to device names,
		$name = $Major_to_name{$major};
		# (the answerbook has an elegant dtrace method for this)
	} else {
		$name = $major;
	}
	printf("%12s %16s %7.2f\n",$name,$ns,($ns*100/$totaldur));
}


# usage - print usage and exit.
#
sub usage {
	print STDERR "USAGE: intrtime [secs]\n";
	print STDERR "   eg,\n";
	print STDERR "       intrtime       # default output, 1 second\n";
	print STDERR "       intrtime 10    # sample for 10 seconds\n";
	exit(1);
}
